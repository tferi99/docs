========
RxJS FAQ
========

- Concept
- What changed in RxJS 6?
- Types of Subjects
- How to describe streams, operators (ASCII marble)?

Observables
-----------
- Hot vs cold observables (creating)
- How to perform a transformation on values from an observable?
- How to process values from an observable with multiple operators?
- How to join multiple observables into single onserver?
- How to join multiple observables into single onserver v2 (flattening)?

Operators
---------
- How to share an observable (shareReplay)?


Angular
-------
- Avoiding memory leaks

Error handling
--------------
- Error handling strategies



----------------------------------------------------------------------------------------------------
Concept
=======
- Observable: This is a class representing a stream of data.

- Observer: This is a class able to emit data.

- Producer: This is what internally produces data, which the Observer
	ultimately emits.
	
- Operator: This is a method on an Observable, which allows us to manipulate the
	stream itself or the data it emits.
	
- Stream: This is synonymous with an instance of an Observable. The reason for it
	being called a stream is that you should think of the data as continuous and not
	really having an end, unless you explicitly define an end.
	
	
----------------------------------------------------------------------------------------------------	
What changed in RxJS 6?
=======================
RxJS 6 (or higher) introduces two important changes compared to RxJS version 5:

	- Different internal structure that requires you to change your import statements
	
	- pipe() as a method to chain your operators, the old way of chaining them will not work
	- Additionally, some operators were renamed.	
	
Migration:

Method 1 (recommended in new or small old projects):
	- fix all unresolved imports
	- replace all operator chaining with pipe()
	- fix all operator calls

Method 2 (not recommended in new projects):

	- npm install --save rxjs-compat

	Behind the scenes, rxjs still supports your old import statements and operator usage 
	but it only does so if it can find the rxjs-compat package in the same project.
	
----------------------------------------------------------------------------------------------------
Types of Subjects
=================
- Subject:
	A Subject is a special type of Observable that allows values to be multicasted to many Observers. 
	Subjects are like EventEmitters.
	
- ReplaySubject:
	A variant of Subject that "replays" or emits old values to new subscribers. It buffers last value 
	and will emit this value immediately to any new subscribers in addition to emitting new values to existing subscribers.
	
- BehaviorSubject:
	A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.
	In addition to emitting new values to existing subscribers.
	
- AsyncSubject:
	A variant of Subject that only emits a value when it completes. 
	It will emit its latest value to all its observers on completion.
	
SEE ALSO:
	https://stackblitz.com/edit/ftoth-rxjs-subjects	
	
	
----------------------------------------------------------------------------------------------------
How to share an observable (shareReplay)?
==================================================================================
Ensure that all observers see the same sequence of emitted items, 
even if they subscribe after the Observable has begun emitting items.

So you can subscribe to observable multiple times and you will have the same result.

To make an observable multicast:

    obs:Observable<Course[]> = this.http.get<Course[]>('/courses');
	...
	
	obsMulti:Observable<Course[]> = obs.pipe(shareReplay());
	
	...
	obs.subscribe(...);
	...
	obs.subscribe(...);

----------------------------------------------------------------------------------------------------
How to perform a transformation on values from an observable?
=============================================================
Use map operator:

	of(1, 2, 3).pipe(
	  map(x => x * 10) 
	).subscribe(console.log);

	-------------------
	10
	20
	30

----------------------------------------------------------------------------------------------------
How to process values from an observable with multiple operators?
=================================================================
In other words: How do I chain operators?

If you have multiple operations which you want to apply sequentially to values from an observer 
then use multiple operators and join them in a chain using pipe():

	of(1, 2, 3).pipe(
	  tap(x => console.log('INPUT: ' + x)),
	  map(x => x+1),
	  filter(x => x % 2 == 0)
	).subscribe(console.log);

	-------------------
	INPUT: 1
	2
	INPUT: 2
	INPUT: 3
	4

----------------------------------------------------------------------------------------------------
How to join multiple observables into single onserver?
======================================================
Use concat() to concatenate observers in a sequence:

	const o1 = of(1, 2, 3);
	const o2 = interval(1000).pipe(       // waiting 1 sec 3 times
		tap(x => console.warn(x + ' : after 1 sec ')),
		take(3));
	const o3 = of(5, 6, 7);
	concat(o1, o2, o3).subscribe(console.log);

	-----------------------
	1
	2
	3
	waiting 1 sec
	0
	waiting 1 sec
	1
	waiting 1 sec
	2
	5
	6
	7
	
NOTE: if any observable in infinite next observables won't be called.


----------------------------------------------------------------------------------------------------
How to join multiple observables into single onserver v2 (flattening)?
======================================================================
SEE ALSO:	https://medium.com/@shairez/a-super-ninja-trick-to-learn-rxjss-switchmap-mergemap-concatmap-and-exhaustmap-forever-88e178a75f1b

Flattening (Flattening just means — "subscribing inside a subscribe"):
	When you map values from an observable into observable and you subscribe to them, too.
	So subscribes in subscribe. Steps are again:
	
	1. Map some value to an observable (you are the one in charge of returning an observable value from them, they just map it)
	2. Then flatten the observable you return ( they just subscribe to it)
	3. Then decide about what to do before / after they flatten (“Flattening Strategy”)	

	
In this case you have to decide what happening with subscriptions.
There are 4 “Flattening Strategies” and there are 4 maps which implement these strategies:

	- Merge Strategy - merge() / mergeMap()
		deciding not to do anything, basically, we just keep subscribing to every new observable that we return from the map.
		
		Real-life use-case:
			For each movie, you might want to also call a 3rd party service, like IMDB to show it’s "up to date" movie rank.
			So you can mergeMap the movie into an http request to IMDB and by that, to ENHANCE YOUR MOVIE CARDS WITH THIS ADDITIONAL DATA.		
	
	- Switch Strategy - switchMap()
		unsubscribing from the last mapped observable, when the new one arrives.
		
		Real-life use-case:
			AutoComplete: If you google something, you press a key on the big input box, so every new input triggers a new ajax request for that 
			search term. But switchMap will make sure that the ongoing http request is being canceled on every new search input, and 
			ONLY THE NEWEST HTTP REQUEST IS LIVE.
		
			Search type-ahaed: 
			
	- Concat Strategy - concat() / concatMap()
		Queuing up every new Observable, and subscribing to a new observable only when the last observable completed.
		
		Real-life use-case:
			Changes reactive form (form.onChanges()) are saved automatically, by flattening these changes into save observers.
			These saves should not overlap each other.
		
	- Exhaust strategy - exhaust() / exhaustMap()
		the "don’t interrupt me" strategy, ignores (and never subscribe to) any new mapped Observable while the current Observable is still emitting values.

		Real-life use-case:
			Login screen: Let’s say you have a login screen with a login button, where you map each click to an login ajax request.
			If the user clicks more than once on the login button, it will cause MULTIPLE CALLS TO THE SERVER, AND YOU PROBABLY DON’T WANT THAT…
			So you can use exhaustMap to temporarily "disable" the mapping while the first http request is still on the go - THIS MAKES SURE YOU NEVER 
			CALL THE SERVER WHILE THE CURRENT REQUEST IS RUNNING.			
	
			Save button: preventing clicking save during previous save and triggering multiple, parallel save process.
	

----------------------------------------------------------------------------------------------------
Error handling strategies
=========================
LIFECYCLE ENDED
---------------
1. Error handling in error callback of subscribe():
	<OBSERVABLE>.pipe(
		...
		...
		...
	).subscribe(
		NEXT,
		ERROR,
		COMPLETED
	);

	for example:
	
		http$.pipe(
			map(res => Object.values(res['payload']),
		).subscribe(
			x => this.current = x;
			err => {
				log(err);
				...
			}
		);

	LIMITATIONS: cannot be recovered, mapping into alternative Observable​
		
		
DURING LIFECYCLE (IN OPERATOR CHAIN)
------------------------------------
using catchError() operator:

2. Catch and Replace Strategy (Alternative Observable returned om error)

	<OBSERVABLE>.pipe(
		...
		...
		...
		catchError(err => <RECOVERY_OBSERVABLE>)
	);

	for example:
	
		http$.pipe(
			map(res => Object.values(res['payload']),
			catchError(err => of([alternativeValue]))
		)

		
3. Catch and Rethrow Strategy:

	<OBSERVABLE>.pipe(
		...
		...
		...
		catchError(err => {
			ERROR_HANDLING (e.g. message)						
			RE-THROW										<<<< here an Observable should be returned
		})
	);

	Example:
	
		http$.pipe(
			map(res => Object.values(res['payload']),
			catchError(err => {
				console.log('Error occcured: ' + err);
				return throwErr(err);
			})
		)

4. Cleanup logic:
	<OBSERVABLE>.pipe(
		...
		...
		...
		catchError(err => {
			ERROR_HANDLING (e.g. message)						
			RE-THROW										<<<< here an Observable should be returned
		}),
		finalize(() => {
			CLEANUP
		})
	);
		
5. Retry Strategy (immediate or delayed):		
		
	NOTE: 
		You can catch error immediately in the 1st operator, or everywhere error can generated,
		Event you can use multiple error catch after any operator.
		

----------------------------------------------------------------------------------------------------
Hot vs cold observables
=======================
- COLD is when your observable creates the producer (Producers created *inside*)
- Producer created and activated during subscription:
- Subscription is receiving all emitted values

	1. creates the producer
	2. activates the producer
	3. starts listening to the producer
	4. unicast

	- How to create:		Observable.create(...)
	
		const cold = Observable.create((observer: any) => {
		  // producer created here
		  const name = 'COLD Observable-1';
		  observer.next(name + ' is ALIVE');							// emitting value here
		  setInterval(() => {
			observer.next(name)											// emitting value here
			}, 2000);
		});

		const subsCold = cold.subscribe(									// producer created and activated here
		  x => console.log('o1: ', x),
		  noop,
		  () => name + ' COMPLETED'
		);
			
- Producers created *outside*
- Not guaranteeded that subscription is receiving all emitted values

	1. shares a reference to a producer
	2. starts listening to the producer
	3. multicast (usually)

		const cold = Observable.create((observer: any) => {
		  // producer created here
		  const name = 'HOT Observable-1';
		  observer.next(name + ' is ALIVE');							// emitting value here
		  setInterval(() => {
			observer.next(name)											// emitting value here
			}, 2000);
		});

		const hot = cold.pipe(share());									// making hot from cold (it can be shareReplay(), too)
		
		const subsHot = hot.subscribe(									// producer created and activated here
		  x => console.log('o1: ', x),
		  noop,
		  () => name + ' COMPLETED'
		);


----------------------------------------------------------------------------------------------------
How to describe streams, operators (ASCII marble)?
==================================================
Marble diagrams are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?! 
There is an ASCII variant of these marble.

Rules:
	- (stands for a time frame)
	a-z (are the values that are next’ed in the stream)
	| (indicates that the stream has completed)
	... (indicates that the stream will keep on living)
	# (indicates that an error occurred)
	^ (indicates where we start subscribing (only for hot streams)

For example:

	const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
	const new$ = interval$
		.pipe(
			skip(1),                            // ---1--2--3--4--5--6...
			take(5),                            // ---1--2--3--4--5|
			filter(v => v % 2 === 0),           // ------2-----4---|
			map(v => v + 1)                     // ------3-----5---|
		)	
	
		
----------------------------------------------------------------------------------------------------
Avoiding memory leaks
=====================
Subscription will keep on living 
	1. until we UNSUBSCRIBE MANUALLY
	2. or THE STREAM IS COMPLETED 
	
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing 
subscription to avoid memory leaks. 
  
  
Method 1 - unsubscribe manually:

	To remove the memory-leak in this component we can keep track of the subscriptions.
	
	class AppComponent implements OnInit, OnDestroy {
		subscriptions = [];
		
		ngOnInit() {
			const interval$ = interval(1000);
			
			// manually keep track of the subscriptions in a subscription array
			this.subscriptions.push(
				interval$.subscribe(r => console.log(r));								// <<<<<<<<<<<<<<
			);
		}

		ngOnDestroy() {
			// when the component get's destroyed, unsubscribe all the subscriptions
			this.subscriptions.forEach(sub => sub.unsubscribe());						// <<<<<<<<<<<<<<
		}
	}

	
Method 2 - force stream to be completed:
	Use a notifier (secondary) Observable to stop target observable(s).
	Notifier should be multicast - so a Subject.
	
	class AppComponent implements OnInit, OnDestroy {
		destroy$ = new Subject();							// notifier (secondary) Observable
		
		ngOnInit() {
			// interval$: 0--1--2--3--4--5--6--...
			// destroy$:  -------------true|
			// result:    0--1--2--3--4|
			
			const interval$ = interval(1000);
			interval$
				// let the interval$ stream live 
				// until the destroy$ Subject gets a value
				.pipe(
					takeUntil(this.destroy$)					// it should be final operator in the pipe
				).subscribe(r => console.log(r));
		}

		ngOnDestroy() {
			// when the component get's destroyed, pass something to the
			// destroy$ Subject
			this.destroy$.next(true);							// complete 
		}
	}	

	
Method 3 - async pipe:

	Async pipe unsubscribes automatically when the component gets destroyed 
	(removes a lot of unsubscribe logic).
	
	
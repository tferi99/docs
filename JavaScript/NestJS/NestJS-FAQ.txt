==========
NestJS-FAQ
==========

Depenency injection
-------------------
- How to resolve circular dependencies?

Validations
-----------
- How to validate a DTO member agains enum?



Troubleshooting
---------------
- ERROR: Nest can't resolve dependencies of the XXX. Please make sure that the argument at index [0] is available in the current context


--------------------------------------------------------------------------------------------------------------------------------------
ERROR: Nest can't resolve dependencies of the XXX. Please make sure that the argument at index [0] is available in the current context
======================================================================================================================================
This error generated when componenet XXX cannot inject element specified in constructor.

Fix:	maybe expected component did not added to 'providers' of current module.

--------------------------------------------------------------------------------------------------------------------------------------
How to validate a DTO member agains enum?
=========================================
- create an array from enum values (ColorValues)
- use validatoy on value property: @IsIn(valuesArray)

	export enum Color {
	  WHITE = 'white',
	  BLACK = 'black',
	  CIRMOS = 'cirmos',
	}

	export const ColorValues = Object.values(Color);

	export class CatsCreateDto {
	  @IsNotEmpty()
	  name: string;

	  @IsNotEmpty()
	  @IsIn(ColorValues)
	  color: Color;
	}

	@Post()
	@UsePipes(ValidationPipe)
	create(@Body() dto: CatsCreateDto) {
		return this.catsService.create(dto);
	}


--------------------------------------------------------------------------------------------------------------------------------------
How to resolve circular dependencies?
=====================================
Nest enables resolving circular dependencies using a technique called forward referencing.

A forward reference allows Nest to reference classes which aren't yet defined using the forwardRef() utility function. 
For example, if ConfigService and ConnectionService depend on each other, both sides of the relationship can use @Inject() and the forwardRef() utility 
to resolve the circular dependency. Otherwise Nest won't instantiate them because all of the essential metadata won't be available.

	export class ConfigService {
		constructor(
			@Inject(forwardRef(() => ConnectionService))
			private connectionService: ConnectionService,
		) {}
		...
	}
	
	export class ConnectionService {
		constructor(
			@Inject(forwardRef(() => ConfigService))
			private configService: ConfigService,
		) {}
	}
	
	
========
NgRx FAQ
========

Basics
------
- Installation
- How to generate basics?


General
-------
- FUC (Frequently Used Commands)
- Steps - How to use it?
- How to setup Store Development Tools?
- Concept
- How we can specify initial state of store?
- What is a side-effect?

Reducers
--------

Selectors
---------

Tips
----
- How to specify feature-level reducers?
- How to specify root object of module specific part of store?
- How to retrieve an object tree for modification?
- How to protect immutable state from writing?

Troubleshooting
---------------
- ERROR: StaticInjectorError... [...Effects -> Actions]: ... NullInjectorError: No provider for Actions!




---------------------------------------------------------------------------------------------------------------
FUC (Frequently Used Commands)
==============================
Generating a feature into 'reducers' directory and register into app.module:

	ng g f reducers/Telephony -m app.module.ts



---------------------------------------------------------------------------------------------------------------
Installation
============
- install:

	npm install @ngrx/schematics --save-dev
	npm install @ngrx/store @ngrx/effects @ngrx/store-devtools @ngrx/router-store @ngrx/entity --save

- set @ngrx/schematics as default schematic collection:

	ng config cli.defaultCollection @ngrx/schematics

  This command adds the following to the angular.json file:

	"cli": {
		"defaultCollection": "@ngrx/schematics"
	}


---------------------------------------------------------------------------------------------------------------
How to setup Store Development Tools?
=====================================
1. npm install @ngrx/store-devtools --save

2. If you generate a store with schematics this way:

		ng generate store AppState --root --module app.module.ts
		
	It adds Store and StoreDevtoolsModule to module:

		@NgModule({
		  ...
		  imports: [
			...
			StoreModule.forRoot(reducers, { metaReducers }),											<<<<< store
			!environment.production ? StoreDevtoolsModule.instrument() : [],							<<<<< dev tools
		  ]
		})

3. Install Chrome extension:	Redux DevTools


---------------------------------------------------------------------------------------------------------------
Concept
=======
1. Action dipatched to store
2. Store calculates new store from current state and action payload
	- by calling all reducers from reducers map
	- a reducer catches action by type and handles it 


         dispatch
Action -----------> 


- Application state fragmented into 'state' (pieces) which are maintained by reducers.
- A single reducer is responsible only for a piece of the state
- state partitions are embedded by state interface

Elements:
	- Store (imported into module)
		--> Reducers (reducers/index.js) - is a map of application state partition and reducer functions
			--> Reducer function
				- swith-case by action types --> <module>/<module>Actions.js		
		
			--> State partition <--- embedded by AppState interface
				- piece-1 ---> type state1 (or interface)
				- piece-2 ---> type state2 (or interface)
				...
				- piece-N ---> type stateN (or interface)
	
	
	
	
Store --> Reducers --> Reducer function
                   --> State partition
	




---------------------------------------------------------------------------------------------------------------
How we can specify initial state of store?
==========================================
- Initial state calculated in response of first 'init' action
- On 'init' action - as usual - ALL REDUCERS are called
- initially reducer get 'undefined' as initial state, so we can assign initial state as DEFAULT PARAMATER to reducer

For example:

	reducers/index.js

	type AuthState = {
	  loggedIn: boolean,
	  user: User
	};

	const initialAuthState: AuthState = {
	  loggedIn: false,
	  user: undefined
	};

	function authReducer(state: AuthState = initialAuthState, action): AuthState {
	  switch (action.type) {
		case AuthActionTypes.LoginAction:
		  return {
			loggedIn: true,
			user: action.payload.user
		  };
		  ...
		default:
		  return state;
	  }
	}

	
- Usable commands	

---------------------------------------------------------------------------------------------------------------
Steps - How to use it?
======================

1. At the beginning add a store to a package

	Generate store into a package:

		ng generate store AppState --root --module app.module.ts
		
		
	By default index.js is generated into /reducers directory.
	To change it specify --statePath <dir>

	For example:

		ng generate store AppStore --statePath ngrx/reducers --root --module ngrx/ngrx.module.ts

		
2. Define action file
	Action file contains action types and actions which are emitted by this module.
	File:
	
		<module path>/<action file>.action.ts
	
	You can generate action file into your module with schematics:
	
		ng generate action <module path>/<action file>
		
	For example:
	
		ng generate action auth/Auth
		
	Here you have to specify:
		- action types
		- actions with payloads
		
	FREQUENTY USED CONVENTION: 
	Data object shipped by action contained by 'payload' member of action:
	
		export enum AuthActionTypes {
		  LoginAction = '[Login] Action',
		  // ... other action types
		}

		// Login action
		export class Login implements Action {
		  readonly type = AuthActionTypes.LoginAction;

		  constructor(public payload: {user: User}) {}					// <<<<<<<<<<<<<<<<< payload
		}
			
		
3. Dispatch action from a component or backend service with a payload:

	store.dispatch(new Login({user}))

	
4. Build state, add reducers

	- reducers/index.js
		Reducers are in index.js generated by store generation.
		
		This JS contains:
		- state interface
		- map of reducers 
	
	- Method 1: add everything to global reducers directly
	
		- add action payload to state interface as property
	
		- add reducer function into reducers action map
	
		- add action handlers (switch-case)
		
	- Method 2: add modul-specific elements to module:

		ng generate reducer <Module> --flat=false --module <module>/<module>.module.ts
			
		It generates: <module>/<module>.reducer.ts		
	
		NOTE: 
			- it works with lazy loaded modules, too
			- during startup 2 actions generated: 
				- 'init' 				: store initialized
				- 'update-reducers'		: module registered
		
5. Create side-effect services
	A side effect is a usual way to synchronize the state of elements
	outside the store transparently in the background.

	You can generate side-effect service into your module with schematics:
	
		ng generate effect <module>/<Module> --module <module>/<module>.module.ts
		
	For example:
	
		ng generate effect auth/Auth --module auth/auth.module.ts


6. Add selector to access a piece of state


7. Do all in a single step:

	ng generate feature <module>/<Module> --module <module>/<module>.module.ts

		
---------------------------------------------------------------------------------------------------------------
What is a side-effect?
======================
A side effect is a usual way to synchronize the state of elements
outside the store transparently in the background.

So the state is also being sent to 3rd-party elements (database, local storage).

Side effects are implemented as services:

	import { Injectable } from '@angular/core';
	import { Actions, Effect } from '@ngrx/effects';

	@Injectable()
	export class NgrxEffects {

	  constructor(private actions$: Actions) {}
	}

	'actions$' observable injected into effect service.
	Whenever an action is dispatched to store this observable emits a value.

---------------------------------------------------------------------------------------------------------------
ERROR: StaticInjectorError... [...Effects -> Actions]: ... NullInjectorError: No provider for Actions!
======================================================================================================
After added Effects I got this error:

	main.ts:12 Error: StaticInjectorError(AppModule)[NgrxEffects -> Actions]: 
	  StaticInjectorError(Platform: core)[NgrxEffects -> Actions]: 
		NullInjectorError: No provider for Actions!
		at NullInjector.push../node_modules/@angular/core/fesm5/core.js.NullInjector.get (core.js:8896)
		at resolveToken (core.js:9141)
		at tryResolveToken (core.js:9085)
		at StaticInjector.push../node_modules/@angular/core/fesm5/core.js.StaticInjector.get (core.js:8982)
		at resolveToken (core.js:9141)
		at tryResolveToken (core.js:9085)
		...

Fix-1
-----
If EffectsModule added before StoreModule into imports of (app) module, change the order.
StoreModule SHOULD BE THE 1ST.
		
Fix-2
-----
If you generated Effects into a module add EffectsModule import into app module, too - after StoreModule:

	@NgModule({
	  declarations: [
		...
	  ],
	  imports: [
		...
		StoreModule.forRoot(reducers, { metaReducers }),
		!environment.production ? StoreDevtoolsModule.instrument() : [],
		EffectsModule.forRoot([])															<<<<<<<<< here
	  ],
	  providers: [],
	  bootstrap: [AppComponent]
	})
	export class AppModule { }

	
---------------------------------------------------------------------------------------------------------------
How to specify feature-level reducers?
======================================



			
---------------------------------------------------------------------------------------------------------------
How to specify root object of module specific part of store?
============================================================
If a module has its own reducer then payload of actions will be mapped into state with a module specific offset.

This node will be specified during registering StoreModule into module:

	@NgModule({
	  declarations: [MainComponent, LoginComponent, LogoutComponent],
	  imports: [
		CommonModule,
		ReactiveFormsModule,
		StoreModule.forFeature('auth', fromAuth.authReducer),					<<<<<<<< here: 'auth'
		EffectsModule.forFeature([AuthEffects]),
	  ]
	})
	export class NgrxModule { }

---------------------------------------------------------------------------------------------------------------
How to protect immutable state from writing?
============================================
In development time use 'storeFreeze'. 
If you change incoming state in this case an error will be thrown:

	at authReducer (http://localhost:4201/main.js:1791:28)
	core.js:15724 ERROR TypeError: Cannot assign to read only property 'loggedIn' of object '[object Object]'
		at http://localhost:4201/vendor.js:89792:20
		at combination (http://localhost:4201/vendor.js:89744:35)
		...
		
Configuration:
--------------
1. install:
	
	npm i --save-dev ngrx-store-freeze

2. Put 'storeFreeze' into root store config (reducers/index.ts) into metaReducers:

	export const metaReducers: MetaReducer<AppState>[] = !environment.production ? [storeFreeze] : [];


'storeFreeze' is a meta-reducer (running before/after? normal reducers) which sets walks the current state 
recursively and sets all propeties to read-only. It also protects against adding new properties.

---------------------------------------------------------------------------------------------------------------
How to retrieve an object tree for modification?
================================================
Main rule: don't mutate previos state.

That means if you retrieve an object from store you cannot change members of it.

- Solution 1 - simple object:
	If you have a simple object in sub-tree and you want to change properties directly use spread operator:
	
	
- Solution 2 - multi-level object tree:
	If you have a complex object you want to change properties directly create a deep-copy from it:
	
		import * as _ from 'lodash';

		ngOnInit() {
			this.gridSubscription = this.store.pipe(
				select(selectGrids),
			).subscribe(
				grids => this.dashboard = _.cloneDeep(grids)					<<<<<<<<<<<<<<<<<< deep copy
			);
		}
		
- Solution 3 - simple object with form
	With reactive form (created by FormBuilder) you can change a properties of an object directly,
	since inthis case form values copied from store object:
	
	
		this.form = fb.group({
			description: [course.description, Validators.required],						<<<<<< course is an object from state
			category: [course.category, Validators.required],
			longDescription: [course.longDescription, Validators.required],
			promo: [course.promo, []]
		}
	





===========
Angular FAQ
===========

General
-------
- Structure of an Angular application
- Build architecture
	- Bootstrap (4 or above)
	- FontAwesome
- How to add Bootstrap to an Angular project?
- Bootstrapping Angular application
- Lifecycle Hooks
- i18n
- Change detection

Configuration
-------------
- Easy installation of development environment
- How to configure TS?
- How to configure TSLint?
- How to add global styles with Angular CLI?
- How to access angular-cli server from external host?
- How to specify default port (4200) of angular-cli server?
- How to analyze/update package versions?


Scaffolding
-----------
- Schematics
- How to set default schematics collection?

Directives, Components
----------------------
- What is a directive? Directive vs component
- How to set CSS class of host element from component code?
- How to change the default prefix of component to stop tslint warnings
- How to set component input with a literal value?
- How to prevent adding NgForm to forms automatically?
- Parent-child component interaction

RxJS
----
- How to bind an event observable to an HTTP element?
- Howto use boolean observable with async pipe and ngIf?

Design, CSS
-----------
- How works component level CSS?
- How to set browser title?

Routing
-------
- How to navigate from a controller code?

Tips
----
- Bindings:
	- Property binding or interpolation?
	- Attribute binding
	- Class binding
	- Style binding
	- Event binding
	- Data binding
		- Bindigs
- How to use interpolation (template expression)?
- Conditional or dynamic CSS Style/Class
- User input with forms
- How to control form UI by validation status?
- How to check empty values in interpolations?
- How to access DOM elements from a controller?
- Null check on objects
- How to interpolate enum values in template?

Services
--------
- How to use a service?

HTTP, Rest
----------
- How to prototype test Rest services?

Development
-----------
- How to debug Angular?
- How to generate components?
- Howto get usable Angular CLI functions?

Deployment
----------
- How to deploy for production?

Troubleshooting
---------------
- How to get versions?
- TSLint: Type ... trivially inferred from a ... literal, remove type annotation (no-inferrable-types)
- ERROR:	Can't bind to 'formControl' since it isn't a known property of 'input'  
- How to trace value of  Reactive form?
- ERROR: Unexpected token } in JSON at position ...
- Property 'map' does not exist on type 'Observable<...>'
- ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'
- ERROR: No provider for ControlContainer ("[ERROR ->]<form...
- ERROR: Uncaught Error: Unexpected directive '...' imported by the module '...'. Please add a @NgModule annotation
- ERROR: Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.

--------------------------------------------------------------------------------------------------------------------------------------------------
How to add Bootstrap to an Angular project?
===========================================
SEE ALSO:	https://ng-bootstrap.github.io/#/getting-started

NOTE:	Should I add bootstrap.js or bootstrap.min.js to my project?

			No, the goal of ng-bootstrap is to completely replace JavaScript implementation for components. 
			Nor should you include other dependencies like jQuery or popper.js. 
			It is not necessary and might interfere with ng-bootstrap code.
			
- Installation:			

	npm install --save @ng-bootstrap/ng-bootstrap

- Usage:

	import {NgbModule} from '@ng-bootstrap/ng-bootstrap';

	@NgModule({
	  ...
	  imports: [NgbModule, ...],
	  ...
	})
	export class YourAppModule {
	}	
--------------------------------------------------------------------------------------------------------------------------------------------------
Build architecture
==================
Prerequisities:
	If you want a pure, clean system delete all NPM packages from:

		Win:

			HOME\AppData\Roaming\npm\node_modules 

Install the following packages:

	npm i -g typescript
	npm i -g tslint
	npm i -g @angular/cli
	
		Typescript
		TSLint:			TSLint is an extensible static analysis tool that checks TypeScript code.
		Codelyzer:		A set of tslint rules for static code analysis of Angular TypeScript projects.

Optional:
	
	Bootstrap (4 or above):		
		
		npm install --save @ng-bootstrap/ng-bootstrap
		
		SEE ALSO:		How to add Bootstrap to an Angular project?	
		
	FontAwesome:
		Method 1 - npm:
			- install:
				
				npm install @fortawesome/fontawesome-free

			- configure:
			
				add this entry to angular.json (into "styles"):
				
					"styles": [ 
						...
						"./node_modules/@fortawesome/fontawesome-free/css/all.css"
					],
				
			- usage:

				<i class="fa fa-check"></i>


			SEE ALSO:	https://fontawesome.com/how-to-use/on-the-web/setup/using-package-managers
	
		Method 2 - Angular-fontawesome:
			- install:

				npm i @fortawesome/fontawesome-svg-core
				npm i @fortawesome/free-solid-svg-icons
				npm i @fortawesome/angular-fontawesome
	
			- usage:

				src/app/app.module.ts:

					import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';
					...
					imports: [
						...,
						FontAwesomeModule
					],
					
				src/app/app.component.ts:

					import { Component } from '@angular/core';
					import { faCoffee } from '@fortawesome/free-solid-svg-icons';
					 
					@Component({
					  selector: 'app-root',
					  templateUrl: './app.component.html',
					  styleUrls: ['./app.component.css']
					})
					export class AppComponent {
					  title = 'app';
					  faCoffee = faCoffee;
					}

				src/app/app.component.html:

					<fa-icon [icon]="faCoffee"></fa-icon>

			SEE ALSO:	https://fontawesome.com/how-to-use/on-the-web/using-with/angular

--------------------------------------------------------------------------------------------------------------------------------------------------
Structure of an Angular application
===================================
- Everything is directive
- components are directives with template
- application contains a component tree, where there is one main component 

Compiled index.html contains JS references which loads main.js (compiled from main.ts) ---> <app-root>

--> main.ts bootstraps main module (e.g. AppModule)
	platformBrowserDynamic().bootstrapModule(AppModule)
	
		--> app.component.ts
			--> app.component.html
				<app-heroes>
			--> app.component.css


			
--------------------------------------------------------------------------------------------------------------------------------------------------
Bootstrapping Angular application
=================================

Development with Angulkar-CLI:

	ng serve -> angular.json -> main.ts -> @NgModule AppModule -> AppComponent

	
	Angular has a powerful concept of modules. When you boot an Angular app, you’re not booting a
	component directly, but instead you create an NgModule which points to the component you want
	to load.
	
ng serve
	• ng serve looks at .angular-cli.json which specifies main.ts as our entry point (and index.html as our index file)
	• main.ts bootstraps AppModule
	• AppModule specifies that AppComponent is the top level component
	• … and then AppComponent renders the rest of our app!

	==> angular.json
			"main": "src/main.ts"			// this is entry point
			
			It bootstraps an Angular module:			
			
				platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.log(err));
			
			==> AppModule
			
				AppModule specifies which component to use as the top-level component:
				
					bootstrap: [AppComponent]
			
--------------------------------------------------------------------------------------------------------------------------------------------------
Easy installation of development environment
============================================
- Install npm
	NPM is part of NodeJS so install NodeJS if you don't have it yet.
	
	OR

	- Update npm

		npm install npm -g

- Install Angular CLI

		
	npm install -g @angular/cli

- Create a new project

	ng new my-app

- Start app

	cd my-app
	ng serve --open
	OR
	npm start
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Bindigs
=======
Method 1:

	<div class="field">
		<label for="title">Title:</label>
		<input name="title" id="title" #newtitle>
	</div>
	...
	<button (click)="addArticle(newtitle, newlink)" class="ui positive right floated button">Submit link</button>

	
	export class XComponent {
		addArticle(title: HTMLInputElement, link: HTMLInputElement): boolean {
			console.log(`Adding article title: ${title.value} and link: ${link.value}`);
			return false;
		}
	}
	

Method 2:

	<li>{{hero.name}}</li>														<--
	<hero-detail [hero]="selectedHero"></hero-detail>							<--
	<li (click)="selectHero(hero)"></li>										-->
	<input [(ngModel)]="hero.name">												<-->		

	
DOM                             COMPONENT
         <-----------------                       {{v}}					:  The {{hero.name}} interpolation displays the component's hero.name property value within the <li> element.
		 
		 <-----------------                       [property]="value"	: The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to 
																			the hero property of the child HeroDetailComponent.
		 
		 ------------------>                      (event)="handler"		: The (click) event binding calls the component's selectHero method when the user clicks a hero's name.
		 
        <------------------>                       [(ngModel)]="value"	: Two-way data binding is an important fourth form that combines property and event binding in a single notation, 
																			using the ngModel directive.
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
What is a directive? Directive vs component
===========================================
- A directive is a class with a @Directive decorator. 
- A component is a directive-with-a-template; 
- @Component decorator is actually a @Directive decorator extended with template-oriented features. 
- While a component is technically a directive, components are so distinctive and central to Angular applications that we separate components from directives.

Two other kinds of directives exist: 
	- structural directives	: Structural directives alter layout by adding, removing, and replacing elements in DOM.
	
		<li *ngFor="let hero of heroes"></li>
		<hero-detail *ngIf="selectedHero"></hero-detail>
	
		*ngFor tells Angular to stamp out one <li> per hero in the heroes list.
		*ngIf includes the HeroDetail component only if a selected hero exists.
		
	- attribute directives	: Attribute directives alter the appearance or behavior of an existing element. 

		<input [(ngModel)]="hero.name">
		
		The ngModel directive, which implements two-way data binding, is an example of an attribute directive. 
		ngModel modifies the behavior of an existing element (typically an <input>) by setting its display value property and responding to change events.
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
How to use a service?
=====================
- Create:
		ng generate service hero
		
	OR write it manually.

- Register
	- To instantiate a service a provider should be registered.
	- In general, add providers to the root module so that the same instance of a service is available everywhere.
	- But you can register a provider in a component, too. Registering at a component level means you get a new instance of the service 
		with each new instance of that component.

	
- Import and inject
	
	- 
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to debug Angular?	
=====================
- Print out model as JSON:

	<div>{{model | json}}</div>

- Put 'debugger' command into JS:

	debugger;
	
	and browser will stop at this location.
	
	Set:	"sourceMap": true
	
		in tsconfig.ts and browser will show source TS instead of generated JS in source panel.
	
- Install Augury Chrome extension 	
	- you can show component hierarchy
	- you can view/change component properties
	

--------------------------------------------------------------------------------------------------------------------------------------------------
How to generate components?	
===========================
General component:

	
Service:
	global:
		ng generate service hero
	module specific:
		ng generate service hero --module=app
	

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to configure TS?
====================
There are multiple tsconfig*.json in hierarchy (in inheritance):




	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to configure TSLint?
========================
TSLint is an extensible static analysis tool that checks TypeScript code for readability, maintainability, and functionality errors.
It uses Codelyzer rules for check Angular code.

Yuo can customize behavior in tslint.json, e.g. changing component selector format add:

	       "component-selector": [
            true,
            "element",
            ["app", "custom"],
            "kebab-case"
        ]
		
		
Be aware of multiple tslint.json, for example latest Angular-CLI generates 

	APP/tslint.json
	APP/src/tslint.json
	
	where src/tslint.json extends the other one.
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to get versions?
====================
Call:		ng --versions

It prints version of all important packages:

	Angular CLI: 6.0.3
	Node: 8.10.0
	OS: win32 x64
	Angular:
	...

	Package                      Version
	------------------------------------------------------
	@angular-devkit/architect    0.6.3
	@angular-devkit/core         0.6.3
	@angular-devkit/schematics   0.6.3
	@schematics/angular          0.6.3
	@schematics/update           0.6.3
	rxjs                         6.2.0
	typescript                   2.7.2


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto get usable Angular CLI functions?
=======================================
ng --help


--------------------------------------------------------------------------------------------------------------------------------------------------
How to set CSS class of host element from component code?
=========================================================
Use @HostBinding('attr.class'). It sets class of rendered element.

For example:

	@Component({
	  selector: 'app-article',
	  templateUrl: './article.component.html',
	  styleUrls: ['./article.component.css']
	})
	export class ArticleComponent implements OnInit {
		@HostBinding('attr.class') cssClass = 'row';
		....
	}
	
is the same as you would put class='row' into parent template where you use <app-article>:

	<app-article ... class='row'>




	
--------------------------------------------------------------------------------------------------------------------------------------------------
TSLint: Type ... trivially inferred from a ... literal, remove type annotation (no-inferrable-types)
====================================================================================================
If you have a member property like this:

	export class CounterComponent implements OnInit {

	  count: number = 0;
	  
	  ...
	}
	
and you have lint error as mentioned.

Problem: type declaration and value assignement is redundant.
Fix: if you have assigned value right in the property declaration remove type declaration.	

	export class CounterComponent implements OnInit {

	  count = 0;
	  
	  ...
	}

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to change the default prefix of component to stop tslint warnings
=====================================================================
Prefix of a component only appearing in template. 
Name of component in file names and in TS does NOT contain prefix.
For example:

	Prefix is:	app

	src/app/user-list
		- user-list.component.css
		- user-list.component.html
		- user-list.component.ts
		
			selector:	app-user-list
		
How to configure allowed prefixes:
	angular-cli.json/projects/prefix					: default prefix, it will be used when AngularCLI generates a new component
	tslint.json/component-selector/3rd array element	: contains 1 prefix or array of prefixes which contains permitted prefix(es)

	- If you want to change prefix to another, then change them 
	- If you want to allow multiple prefixes in change prefix in tslint.json into an array and add multiple prefixes. 
		Then set default prefix in angular-cli.json .
		
If you don't want prefixes you have to remove/comment out component-selector from tslint.json


--------------------------------------------------------------------------------------------------------------------------------------------------
How to use interpolation (template expression)?
===============================================
Double-curly braces: interpolation, iut contains template expression.
- interpolation contains an expression
- expressions access component properties directly

--------------------------------------------------------------------------------------------------------------------------------------------------
How to set component input with a literal value?
================================================
Component input binding in template receives property name and not a value directly by default.

- If you want to set an input with a string literal value directly use '...' in expression:			[input-property]="'value'"
	OR don't use input expression:																	input-property="value"

- number values are recognized automatically:														[input-property]="num-value"
	OR 																								input-property="num-value"
	
TS:
	@Component({
	  selector: 'app-my-form',
	  templateUrl: './my-form.component.html',
	  styleUrls: ['./my-form.component.css']
	})
	export class MyFormComponent implements OnInit {
	  @Input() title: string;
	  @Input() size: number;

	  constructor() {
		this.title = 'default';
		this.size = 3;
	  }

	  ngOnInit() {
	  }
	}
	
Caller template:

	<app-my-form [title]="'literal'" [size]="3.2"></app-my-form>
	OR
	<app-my-form title="literal" [size]="3.2"></app-my-form>
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Conditional or dynamic CSS Style/Class
======================================
Setting styles:
	Method 1:	The simplest way to use this directive is by doing [style.<cssproperty>]="value"
	
		<div [style.background-color]="'yellow'">
			Uses fixed yellow background
		</div>

	Method 2: Another way to set fixed values is by using the NgStyle attribute and using key value pairs for each
			property you want to set, like this:
		
		<div [ngStyle]="{color: 'white', 'background-color': 'blue'}">
			Uses fixed white text on blue background
		</div>
		
		
Conditional class:
	<tag [class.<CSS CLASS>]='<boolean component property>'>

	For example:	Toggle background color with click.
	
	HTML:
		
		<p [class.clicked]='clicked' (click)="onClick()">
		
	TS:
		
		@Component({
		  selector: 'app-css-demo',
		  templateUrl: './css-demo.component.html',
		  styleUrls: ['./css-demo.component.css']
		})
		export class CssDemoComponent implements OnInit {
		  clicked: boolean = false;

		  constructor() {
			this.showTitle();
		  }

		  ngOnInit() {
		  }

		  onClick() {
			this.clicked = !this.clicked;
		  }
		}
		
		
	CSS:
		.clicked {
			background-color: lightgreen;
		}
		
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to add global styles with Angular CLI?	
==========================================
Add new entry to projects/.../styles generated angular.json. E.g:

	"styles": [
	  "src/assets/vendor/semantic.min.css",
	  "src/styles.css"
	],

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to deploy for production?
=============================

	ng build --target=production --base-href /

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to access angular-cli server from external host?
====================================================
It opens server on public interface:

	ng serve --host <local-host-ip>
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to specify default port (4200) of angular-cli server?
=========================================================
- In the new angular.json you now specify a port per "project"

	"projects": {
		"my-cool-project": {
			... rest of project config omitted
			"architect": {
				"serve": {
					"options": {
						"port": 4201
					}
				}
			}
		}
	}

- OR in command line:

	ng serve --port 4201
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
User input with forms
=====================
IN THE BACKGROUND:

	JavaScript objects:
		
		- common ancestor:
			AbstractControl
				- value
				- valid / invalid
				- touched
				- errors
				- pristine (true: not changed yet in UI)
				- dirty (true: changed in UI)
				- ...
	
		- A FormControl represents a single input field - it is the smallest unit of an Angular form.
				
			// create a new FormControl with the value "Nate"
			let nameControl = new FormControl("Nate");
			let name = nameControl.value; // -> Nate
			
			// now we can query this control for certain values:
			nameControl.errors // -> StringMap<string, any> of errors
			nameControl.dirty // -> false
			nameControl.valid // -> true

		- FormGroup: manages multiple FormControls

			let personInfo = new FormGroup({
				firstName: new FormControl("Nate"),
				lastName: new FormControl("Murray"),
				zip: new FormControl("90210")
			})

			// now we can query this control group for certain values, which have sensible
			// values depending on the children FormControl's values:
			personInfo.errors // -> StringMap<string, any> of errors
			personInfo.dirty // -> false
			personInfo.valid // -> true
			
			
	
2 approaches:
	
	- Template driven (FormsModule):

		SEE ALSO:	https://angular.io/guide/forms
	
		The FormsModule gives us template driven directives such as:
		• ngForm and
		• ngModel
		
			template:
			
			  <form #f="ngForm"									<<< ngForm ---> 'f' local variable
					(ngSubmit)="onSubmit(f.value)"				<<< ngSubmit: output event on submit
					class="ui form">

				<div class="field">
				  <label for="skuInput">SKU</label>
				  <input type="text"
						 id="skuInput"
						 placeholder="SKU"
						 name="sku" ngModel>					<<< ngModel: it builds a FormControl and associates this field to f.value.sku
				</div>
				<button type="submit" class="ui button">Submit</button>
			  </form>
		
			controller:
			
			  onSubmit(form: any): void {
				console.log('you submitted value:', form);
			  }

		- NgForm does something handy but non-obvious: it includes the form tag in its selector (instead
			of requiring you to explicitly add ngForm as an attribute). What this means is that if you import
			FormsModule, NgForm will get AUTOMATICALLY attached to any <form> tags you have in your view.

		- The #v=thing syntax says that we want to create a local variable for this view.
			
			<form #f="ngForm" (ngSubmit)="onSubmit(f.value)"		  
			  
		- When we use ngModel with no attribute value we are specifying:
			1. a one-way data binding
			2. we want to create a FormControl on this form with the name sku (because of the name attribute on the input tag)
			
		- There are two important pieces of functionality that NgForm gives us:
			1. A FormGroup named ngForm
			2. A (ngSubmit) output
			
			
	- Model driven / Reactive (using FormBuilder with ReactiveFormsModule gives us directives like):
		
		SEE ALSO:	https://angular.io/guide/reactive-forms
	
		• formGroup and
		• formControl
		
		
		template:
		
		  <form [formGroup]="myForm" (ngSubmit)="onSubmit(myForm.value)" class="ui form">
			<div class="field">
			  <label for="skuInput">SKU</label>
			  <input type="text" id="skuInput" placeholder="SKU" [formControl]="myForm.controls['sku']">		<<< v1
			</div>
			
			<div class="field">
			  <label for="skuInput">SKU</label>
			  <input type="text" id="skuInput" placeholder="Description" formControlName="desc">		<<< v2
			</div>
			
			<button type="submit" class="ui button">Submit</button>
		  </form>
			
		controller:
		
			export class DemoFormSkuWithBuilderComponent implements OnInit {
			  myForm: FormGroup;													<<< form group

			  constructor(fb: FormBuilder) {
				this.myForm = fb.group({
				  'sku': ['ABC123'],
				  'desc': ['']
				});
			  }

			  ngOnInit() {
			  }

			  onSubmit(value: string): void {
				console.log('you submitted values - SKU:', value.sku + ' description:' + value.desc);
			  }
			}
			
		- During injection an instance of FormBuilder will be created and we assign it to the fb variable (in the constructor).
		- There are two main functions we’ll use on FormBuilder:
			• control - creates a new FormControl
			• group - creates a new FormGroup
	
	REMEMBER:
	
		To create a new FormGroup and FormControls implicitly use:
			• ngForm and
			• ngModel
			
		But to bind to an existing FormGroup and FormControls use:
			• formGroup and
			• formControl
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------
How to prevent adding NgForm to forms automatically?
====================================================
SEE ALSO:
	User input with forms
	
Remember how earlier we said that when using FormsModule that NgForm will be AUTOMATICALLY
applied to a <form> element? 

There is an exception: NgForm won’t be applied to a <form> that has formGroup.

If you’re curious, the selector for NgForm is:

	form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]
	
This means you could have a form that doesn’t get NgForm applied by using the ngNoForm attribute:

	<form ngNoForm>
		...
	</form>
	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR:	Can't bind to 'formControl' since it isn't a known property of 'input'
==============================================================================
You are using Reactive form but you forgot 
	- to import ReactiveFormsModule into main module 
	OR
	- to add ReactiveFormsModule to 'imports' of @NgModule

	
	import { ReactiveFormsModule } from '@angular/forms';
	...
	
	@NgModule({
	  imports:      [ ReactiveFormsModule ],
	  ...
	})	 

--------------------------------------------------------------------------------------------------------------------------------------------------
How to trace value of  Reactive form?
=====================================
You can access values 

Print to template with JSON pipe:

	<h5>Form value: {{form.value | json}}</h5>


--------------------------------------------------------------------------------------------------------------------------------------------------
How to control form UI by validation status?
============================================

- Disable submit button if form is not valid:

	<button type="submit" [disabled]="!form.valid">OK</button>


--------------------------------------------------------------------------------------------------------------------------------------------------
How to check empty values in interpolations?
============================================
In ngIf simply use variable (it can be non-boolean, too - eg. object, string, ...):

	<span *ngIf="errorMsg" style="background-color: red">{{errorMsg}}</span>

	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Unexpected token } in JSON at position ...
=================================================
Check angular.json for sytax error(s).



--------------------------------------------------------------------------------------------------------------------------------------------------
How to access DOM elements from a controller?
=============================================
- template reference variable

	<form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... </form>

	
-  template input variable:	
	
	
	<button *ngFor="let hero of heroes" (click)="deleteHero(hero)">{{hero.name}}</button>
	
-	@ViewChild:

	<input #myname>
	
	@ViewChild('myname') input; 
	
	ngAfterViewInit() {
	  console.log(this.input.nativeElement.value);
	}


	
--------------------------------------------------------------------------------------------------------------------------------------------------
Attribute binding
=================
<tr><td colspan="{{1 + 1}}">Three-Four</td></tr>

And you get this error:

	Template parse errors:
	Can't bind to 'colspan' since it isn't a known native property
	
Why? 
As the message says, the <td> element does not have a colspan property. It has the "colspan" ATTRIBUTE, but INTERPOLATION AND PROPERTY BINDING CAN SET ONLY PROPERTIES, NOT ATTRIBUTES.	
You need attribute bindings to create and bind to such attributes:

	 <tr><td [attr.colspan]="1 + 1">One-Two</td></tr>


--------------------------------------------------------------------------------------------------------------------------------------------------
Property binding or interpolation?
==================================
They do the same - but with interpolation and property binding:
	
	<p><img src="{{heroImageUrl}}"> is the <i>interpolated</i> image.</p>
	<p><img [src]="heroImageUrl"> is the <i>property bound</i> image.</p>

	<p><span>"{{title}}" is the <i>interpolated</i> title.</span></p>
	<p>"<span [innerHTML]="title"></span>" is the <i>property bound</i> title.</p>	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Class binding
=============
-  all-or-nothing, replacement binding with string literal:

	<div class="bad curly special" [class]="badCurly">Bad curly</div>
	
- add/remove class with boolean expression:

	<div [class.special]="isSpecial">The class binding is special</div>
	

--------------------------------------------------------------------------------------------------------------------------------------------------
Style binding
=============
You can set inline styles with a style binding [style.style-property]:

	<button [style.color]="isSpecial ? 'red': 'green'">Red</button>
	<button [style.background-color]="canSave ? 'cyan': 'grey'" >Save</button>
	<button [style.font-size.em]="isSpecial ? 3 : 1" >Big</button>
	<button [style.font-size.%]="!isSpecial ? 150 : 50" >Small</button>


--------------------------------------------------------------------------------------------------------------------------------------------------
Event binding
=============
Event binding syntax consists of a TARGET EVENT name within parentheses on the left of an equal sign, and a quoted TEMPLATE STATEMENT on the right.
	
	<button (click)="onSave()">Save</button>
	


--------------------------------------------------------------------------------------------------------------------------------------------------
Parent-child component interaction
==================================
PARENT =======> CHILD

	- Pass data from parent to child with input binding

		parent:
			<app-hero-child *ngFor="let hero of heroes" [hero]="hero"></app-hero-child>
			
		child:
			selector: 'app-hero-child',
			@Input() hero: Hero;


	- Intercept input property changes with a setter

		Same as 'Pass data from parent to child with input binding' but with a setter.

		parent:
			<app-name-child *ngFor="let name of names" [name]="name"></app-name-child>
		
		child:
			@Input()
			set name(name: string) {
				this._name = (name && name.trim()) || '<no name set>';
			}

	- Intercept input property changes with ngOnChanges()
		parent:
			app-version-child [major]="major" [minor]="minor"></app-version-child>

		child:
			export class VersionChildComponent implements OnChanges {

				ngOnChanges(changes: {[propKey: string]: SimpleChange}) {
					// propKey contains changed property
				}
			}

CHILD =======> PARENT
	
	- Parent listens for child event

		child:
			selector: 'app-voter',
			@Output() voted = new EventEmitter<boolean>();
			
			vote(agreed: boolean) {
				this.voted.emit(agreed);
			}
	
		parent:
			<app-voter *ngFor="let voter of voters" (voted)="onVoted($event)"></app-voter>		
	
	
	- Parent interacts with child via local variable
		parent:
			<button (click)="timer.start()">Start</button>
			<button (click)="timer.stop()">Stop</button>
			<div class="seconds">{{timer.seconds}}</div>
			<app-countdown-timer #timer></app-countdown-timer>

		child:
			selector: 'app-countdown-timer'
			
			seconds: number;
			start() { this.countDown(); }
			stop()  {
				this.clearTimer();
				this.message = `Holding at T-${this.seconds} seconds`;
			}		
			
	- Parent calls an @ViewChild()
		The local variable approach is simple and easy. But it is limited because the parent-child wiring must 
		be done entirely within the parent template. The parent component itself has no access to the child.
		
		parent:
			@ViewChild(CountdownTimerComponent)
			private timerComponent: CountdownTimerComponent;			

		child:
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------
How works component level CSS?
==============================
.....
.....
.....

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Null check on objects
=====================
Example:		<span class="subhead">{{project?.category}}</span>

? is the safe navigation operator. 
It checks whether the variable is null or undefined so that our template won't try to select a property of something falsy.

Without ? operator if 'project' is null an error will generated:

	TypeError: Cannot read property 'category' of null in [null].


--------------------------------------------------------------------------------------------------------------------------------------------------
How to prototype test Rest services?
==============================
https://jsonplaceholder.typicode.com/

- create a repository in GitHub
- create db.json into repository with the content like this:

{
    "posts": [
        {
            "id": 1,
            "title": "Post 1"
        },
        {
            "id": 2,
            "title": "Post 2"
        },
        {
            "id": 3,
            "title": "Post 3"
        }
    ],
    "person": [
        {
            "id": 1,
            "name": "John Smith",
            "gender": "M"
        },
        {
            "id": 2,
            "name": "Jane Doe",
            "gender": "F"
        }
    ],   
    "comments": [
        {
            "id": 1,
            "body": "some comment",
            "postId": 1
        },
        {
            "id": 2,
            "body": "some comment",
            "postId": 1
        }
    ],
    "profile": {
        "name": "typicode"
    }
}


TIP:
	- changes not updated immediately, maybe a few of minutes later 
	
		After changing db.json check changes with:
	
			https://my-json-server.typicode.com/<user>/<repo>/db
		

--------------------------------------------------------------------------------------------------------------------------------------------------
Property 'map' does not exist on type 'Observable<...>'
=======================================================
For versions of RxJS 6.x.x and above, you will have to use pipeable operators as shown in the code snippet below:

	import { map } from 'rxjs/operators';
	import { HttpClient } from '@angular/common/http';

	// ...
	export class MyComponent {
	  constructor(private http: HttpClient) { }
	  getItems() {
		this.http.get('https://example.com/api/items').pipe(map(data => {})).subscribe(result => {
		  console.log(result);
		});
	  }
	}
	
	
operators: Pipeable operators must now be imported from rxjs like so: 

	import { map, filter, switchMap } from 'rxjs/operators';
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to set browser title?	
=========================
Use Title service:

	import {Title} from '@angular/platform-browser';
	...

	public constructor(titleService: Title ) {
		titleService.setTitle(this.title);
	}

	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'
=========================================================================
EXPLANATION
-----------
	In order to use the new forms library we need to first make sure we import the forms library in our
	NgModule.

		import {
			FormsModule,
			ReactiveFormsModule
		} from '@angular/forms';
		
		...
		@NgModule({
			declarations: [
				...
			],
			imports: [
				BrowserModule,
				FormsModule, 						// <-- add this
				ReactiveFormsModule 				// <-- and this
			],
			...
		})
		class FormsDemoAppModule {}

	This ensures that we’re able to use the form directives in our views. At the risk of jumping ahead,
	the FormsModule gives us template driven directives such as:

		• ngModel and
		• NgForm
		
	whereas ReactiveFormsModule gives us model driven directives like

		• formControl and
		• ngFormGroup

COUSE
-----
	If you build a reactive (model driven) form, like this:

		<form class="section" [formGroup]="form" (ngSubmit)="onSubmit()">
			...
		</form>
		
	, but you forget import ReactiveFormsModule into your (app) module
	these directives won't be added to <form> tags.
		

--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: No provider for ControlContainer ("[ERROR ->]<form...
============================================================
SEE ALSO:	ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'

Similarly to previous problem:
	If you have a (non-reactive) form but you forget to add
		
		FormsModule
		
	to your (app) module then you will get this error.
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Uncaught Error: Unexpected directive '...' imported by the module '...'. Please add a @NgModule annotation
=================================================================================================================
This error frequently comes up when we are not importing, providing, or declaring the angular modules, services, 
components properly.

Make sure that we should only

	- import modules and not the components or services
	- declare components and not the modules or services.
	- provide services and not components or modules.


--------------------------------------------------------------------------------------------------------------------------------------------------
How to bind an event observable to an HTTP element?
===================================================
1. Add # element reference to elent

2. Bind this reference into TS with @ViewChild

3. Create observable in ngAfterViewInit with fromEvent(...), use nativeElement of HTML element reference.

View:

	<span #clickTarget>Click here to ...</span>

TS:
	@ViewChild('clickTarget') clickTarget: ElementRef;

	ngAfterViewInit(): void {
		fromEvent(this.clickTarget.nativeElement, 'click').pipe(
		  tap(() => console.log('Clicked --> start processing')),
		  concatMap(this.startLongProcessing)
		).subscribe(
		  (evt) => console.log('event: ' + evt),
		  noop,
		  () => console.log('----------- processing completed -----------------')
		);
	}


--------------------------------------------------------------------------------------------------------------------------------------------------
How to interpolate enum values in template?
===========================================
Add reference pointing to enum as member ito class and you will be able to access from template:

TS:
	enum FlatteningType {
	  MERGE = 'merge',
	  SWITCH = 'switch',
	  CONCAT = 'concat',
	  EXHAUST = 'exchaust'
	}

	export class FlatteningComponent implements OnInit, AfterViewInit {
		...
		flatteningTypeEnum = FlatteningType;
		...
	}

HTML:

	<input type="radio" id="flattMerge" name="flatteningType" [(ngModel)]="flatteningType" value="{{flatteningTypeEnum.MERGE}}">
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.	
=======================================================================================================
??????????????????


--------------------------------------------------------------------------------------------------------------------------------------------------
Lifecycle Hooks
===============
Lifecycle hooks are:
	- ngOnChanges					: ngOnChanges called BEFORE ngOnInit() and WHENEVER one/more data-bound input properties change.
										It means, whenever any input properties changed than the code under this function will be triggered
										
	- ngOnInit						: ngOnInit is there to give us a signal that Angular has finished initializing
	
	- ngDoCheck						:  it’s called WHENEVER any changes during the app execution happened.
										In addition, it’s called IMMEDIATELY AFTER ngOnChange and ngOnInit.
	
	- ngAfterContentInit
	- ngAfterContentChecked
	- ngAfterViewInit
	- ngAfterViewChecked
	- ngOnDistroy
	

https://angular.io/guide/lifecycle-hooks


--------------------------------------------------------------------------------------------------------------------------------------------------
How to analyze/update package versions?		
=======================================
- To analyze package versions:

	ng update
	
	
		We analyzed your package.json, there are some packages to update:

		  Name                               Version                  Command to update
		 --------------------------------------------------------------------------------
		  rxjs                               6.3.3 -> 6.5.2           ng update rxjs

	
	
	
	
- To update a package:

	ng update <package>
	
	as recommended from table.
	
- To update all:

	ng update --all
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Schematics
==========
- A schematic is a template-based code generator.
- Schematics are packaged into COLLECTIONS and installed with npm.
- Schematics that are included in the 

		@schematics/angular 
		
	collection are run BY DEFAULT by the commands ng generate and ng add. 

-  You can specify a particular schematic (or collection of schematics) to generate, using the long form:
	
	ng generate my-schematic-collection:my-schematic-name

  OR
  
	ng generate my-schematic-name --collection collection-name	
	
- To get available schematics:

		ng generate --help


--------------------------------------------------------------------------------------------------------------------------------------------------
How to set default schematics collection?
=========================================
If you want to call a schematic from a non-default colection the syntax is:

	ng generate my-schematic-collection:my-schematic-name


Call this command in a project:
				
	ng config cli.defaultCollection @ngrx/schematics

Running this command adds the following to the angular.json file:

	"cli": {
		"defaultCollection": "@ngrx/schematics"
	}

	
Without this you from 	
	
	
After this 	you will be able to call schematics from default collection without collection name:

	
	ng generate my-schematic-name
	
  OR
		
	ng g my-schematic-name
	

--------------------------------------------------------------------------------------------------------------------------------------------------
How to navigate from a controller code?
=======================================
- inject router 

  constructor(private router: Router, ...) { }
	

- call:

	this.router.navigateByUrl(url);
	OR
	this.router.navigate(commands);

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Howto use boolean observable with async pipe and ngIf?
======================================================
You have a boolean observable in a component:

	main.component.ts:
	
		export class MainComponent implements OnInit {
			isLoggedIn$: Observable<boolean>;
			...
		}
	
To render the true value is trivial, just use async pipe.
But what about false? Evaluate it and compare with 'false'.

	main.component.html:
	
		<div class="container mt-2">
		  <ngrx-login *ngIf="(isLoggedIn$ | async) === false"></ngrx-login>
		  <ngrx-logout *ngIf="isLoggedIn$ | async"></ngrx-logout>
		</div>

--------------------------------------------------------------------------------------------------------------------------------------------------
i18n
====
Steps
-----
	1. add i18n (i18n-*) tag to your template tags (properties)
	
		i18n="meaning|description@@id"
		
		For example:
		
			<h1 i18n="main title">This is a title text</h1>
			<h1 i18n="@@mainTitle">This is a title text</h1>
	
	2. call 'xi18n' to generate locale files, e.g:
	
		ng xi18n --output-path locale
	
		The command can read and write files in three translation formats:
			- XLIFF 1.2 (default)
			- XLIFF 2
			- XML Message Bundle (XMB)
			
		You can specify the translation format explicitly with the --i18nFormat command option, as illustrated in these example commands:


			ng xi18n  --i18n-format=xlf
			ng xi18n  --i18n-format=xlf2
			ng xi18n  --i18n-format=xmb
	
	3. (Optional) You can specify the base locale of your app with the --i18n-locale command option (default: en):
	
		ng xi18n  --output-path locale --i18n-format=xlf --i18n-locale en
		
		The extraction tool uses the locale to add the app locale information into your translation source file. 
		This information is not used by Angular, but external translation tools may need it.
	
	4. 	Translate
	
	5. Copy back:
		- Rename the translated file. Add locale ID (e.g.: messages.fr.xlf for the French language translation).
		- Put the copy in the locale folder.

Translation in detail
---------------------
	

Rules
-----
	-  Don't call private methods, fields or properties from the HTML
	
		When compiling the *.ts code to *.js, AOT refuse to connect non-public members with the HTML template.

	In detailed:
		
		For a given component all its members (methods, properties) accessed by its template must be public in the AOT compilation scenario.
		This is due to the fact that a template is turned into a TS class. A generated class and a component are 2 separate classes now and 
		you can't access private members cross-class.		


--------------------------------------------------------------------------------------------------------------------------------------------------
Change detection
================
SEE ALSO:
	https://medium.com/@bencabanes/angular-change-detection-strategy-an-introduction-819aaa7204e7
	https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/
	https://blog.nrwl.io/essential-angular-change-detection-fe0e868dcc00
	https://blog.angular-university.io/onpush-change-detection-how-it-works/
	https://netbasal.com/optimizing-the-performance-of-your-angular-application-f222f1c16354
	
- Change Detection means updating the view (DOM) when the data has changed.
	2 steps:
	- Update the application model (developer);
	- Reflect the state of the model in the view (Angular).
	
- Angular provides you 2 Change Detection Strategies:
	1. default
	2. onPush
	
##############################################################################################################
By default, Angular runs change detection ON ALL COMPONENTS EVERY TIME SOMETHING CHANGES IN YOUR APP 
— from a click event to data received from an ajax call. ( user events, timers, xhr, promises, etc. )	
##############################################################################################################	
		
	
1. Default
----------
By default, Angular makes no assumption on what the component depends upon. 
So it has to be conservative and will checks every time something may have changed, this is called DIRTY CHECKING. 

In a more concrete way, it will perform checks for:
	- each browser events
	- timers
	- XHRs
	- promises
	
2. onPush
---------
It will rely only on the change of the:
	- input references
	- some events triggered by itself (the component) or one of its children
	- or the use of the async pipe in the template
	- lastly, you, the developer, can ask explicitly Angular to do it with the 
	
		componentRef.markForCheck()
		
		
	When using OnPush detectors, then the framework will check an OnPush component 
		- when any of its input properties changes, 
		- when it fires an event, 
		- or when an Observable fires an event
		
		
Who triggers change detection?
------------------------------
Angular at startup time will patch several low-level browser APIs.
In fact, a lot of browser APIs are patched by Zone.js to transparently trigger Angular change detection, 
such as:

	- addEventListener()
	- all browser events (click, mouseover, keyup, etc.)
	- setTimeout() and setInterval()
	- Ajax requests
	- Websockets
	
Example of patch:

	function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
		
        // and then run Angular-specific functionality
        var changed = angular2.runChangeDetection();
         if (changed) {
             angular2.reRenderUIPart();
         }
     });
	}		

How does it detect changes?
---------------------------
- By default, Angular Change Detection works by checking if the value of template expressions have changed. This is done for all components.
- By default, Angular does not do deep object comparison to detect changes, it only takes into account properties used by the template.




	

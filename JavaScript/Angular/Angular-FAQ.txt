===========
Angular FAQ
===========

General
-------
- Structure of an Angular application
- Build architecture
	- Bootstrap (4 or above)
	- FontAwesome
- How to add Bootstrap to an Angular project?
- Bootstrapping Angular application
- Lifecycle Hooks
- i18n
- Change detection
- Why called change detection 2x in developer mode?
- How to use NgRx in Nx monorepo?

Configuration
-------------
- Easy installation of development environment
- How to configure TS?
- How to configure TSLint?
- How to add global styles with Angular CLI?
- How to access angular-cli server from external host?
- How to specify default port (4200) of angular-cli server?
- How to analyze/update package versions?

Scaffolding
-----------
- Schematics
- How to set default schematics collection?

Directives, Components
----------------------
- What is a directive? Directive vs component
- How to set CSS class of host element from component code?
- How to change the default prefix of component to stop tslint warnings
- How to set component input with a literal value?
- How to set component input with a boolean value?
- Parent-child component interaction

Templating
----------
- How to use interpolation (template expression)?
- Templating - structural directives
- Templating expressions
- ng-template directive
- ng-content directive
- ERROR: Can't have multiple template bindings on one element
- ng-container directive
- ngTemplateOutlet
- Howto inject a template into a component (template reference)?
- How to project content from parent to child component?
- @ViewChild vs @ContentChild


Data input, Forms
-----------------
- How to use forms
- How to use ngModel?
- How to prevent adding NgForm to forms automatically?
- How to control form UI by validation status?
- Validation hints
- How Angular store control state information to CSS class?
- Form styling tips for validation
- How can you reference a FormControl behind an input field?
- How to group input values in model?
- Radio button
- Howto set/patch/reset form values of forms?
- Howto generate FormControls dynamically?
- Howto display error-specific messages on validation errors?
- Howto use datepicker?
- Howto initialize reactive form from route resolver?
- How to save form content without submitting (no save button)?

Observables
-----------
- How to bind an event observable to an HTTP element?
- Howto use boolean observable with async pipe and ngIf?
- Howto avoid multiple subscription with async pipes?

NgRx
----
SEE: ../NgRx/NgRx-FAQ.txt

Design, CSS
-----------
- How works component level CSS?
- How to set browser title?

Routing, navigation
-------------------
- Order of routes
- How to navigate from a controller code?
- Nested routing with Multiple RouterOutlet RouterModule
- How to go back to previous page?
- Passing/retrieving parameter with routing							!!! UNDER CONSTRUCTION !!!
- Howto preserve query parameters for the next navigation?
- Passing data to route
- How to prevent user from accidentaly navigating away?
- Howto specify default child route?

Other Tips
----------
- Bindings:
	- Property binding or interpolation?
	- Attribute binding
	- Class binding
	- Style binding
	- Event binding
	- Data binding

- Conditional or dynamic CSS Style/Class
- How to check empty values in interpolations?
- How to access DOM elements from a controller?
- Null check on objects
- How to interpolate enum values in template?
- How to use environment variables?

Services
--------
- How to use a service?
- How service instances propagated?
- Cross-component communication

HTTP, Rest
----------
- How to prototype test Rest services?
- How to test HTTPS(SSL) in development environment?

Development
-----------
- How to debug Angular?
- How to generate components?
- Howto get usable Angular CLI functions?

Deployment
----------
- How to deploy for production?

Troubleshooting
---------------
- How to get versions?
- TSLint: Type ... trivially inferred from a ... literal, remove type annotation (no-inferrable-types)
- ERROR: Can't bind to 'formControl' since it isn't a known property of 'input'
- How to trace value of  Reactive form?
- ERROR: Unexpected token } in JSON at position ...
- Property 'map' does not exist on type 'Observable<...>'
- ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'
- ERROR: No provider for ControlContainer ("[ERROR ->]<form...
- ERROR: Uncaught Error: Unexpected directive '...' imported by the module '...'. Please add a @NgModule annotation
- ERROR: Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.
- ERROR: Uncaught Error: Can't resolve all parameters for ...
- ERROR: '...' is not a known element
- ERROR: Module not found: Error: Can't resolve 'cache-manager' in '.....\node_modules\@nestjs\common\cache'
- How to dump any (even async) variable from template?

--------------------------------------------------------------------------------------------------------------------------------------------------
How to add Bootstrap to an Angular project?
===========================================
There are 3 ways:
	- Using original Bootstrap 4 assets from npm,
	- Using the ng-bootstrap library,
	- And finally using the ngx-bootstrap

Method 1: bootstrap with angular.json
-------------------------------------
- npm install --save bootstrap
- npm install --save jquery
- open the angular.json file of your project and include:

		node_modules/bootstrap/dist/css/bootstrap.css -> architect/build/styles array,
		node_modules/bootstrap/dist/js/bootstrap.js -> architect/build/scripts array,
		node_modules/bootstrap/dist/js/bootstrap.js -> architect/build/scripts array,

Method 1: bootstrap with index.html
-----------------------------------
- open the src/index.html file and add the following:

	- A <link> tag for adding the bootstrap.css file IN THE <head> section,
	
		<link rel="stylesheet" href="../node_modules/bootstrap/dist/css/bootstrap.css">
		
	- A <script> tag for adding the jquery.js file BEFORE the closing </body> tag,
	
		<script src="../node_modules/jquery/dist/jquery.js"></script>	
  
	- A <script> tag for adding the bootstrap.js file BEFORE the </body> tag.
		
		<script src="../node_modules/bootstrap/dist/js/bootstrap.js"></script> 
		

NOTE: 
	Bootstrap depends on jQuery and Popper.js libraries, and if you don't include them in your project, 
	any Bootstrap components that rely on JavaScript will not work.

	Why not include those libs? For Angular it's better to avoid using libraries that make direct manipulation 
	of the DOM (like jQuery) and let Angular handle that.		
		
		
Method 2: ng-bootstrap

	"Should I add bootstrap.js or bootstrap.min.js to my project? 
	No, the goal of ng-bootstrap is to completely replace JavaScript implementation for components. 
	Nor should you include other dependencies like jQuery or popper.js. 
	It is not necessary and might interfere with ng-bootstrap code Source"

	- npm install --save @ng-bootstrap/ng-bootstrap
	- import the main module:
	
		import {NgbModule} from '@ng-bootstrap/ng-bootstrap';
	
	- Next you'll need to add the module you imported in your app root module:
	
		@NgModule({
			declarations: [/*...*/],
			imports: [..., NgbModule.forRoot()],
			...
		})
		export class AppModule {}
		
		
Method 3: ngx-bootstrap
	
	Angular CLI ng add command will update your Angular project with the necessary ngx-bootstrap dependencies, 
	make changes to package.json, angular.json and will execute initialization code:
	
		ng add ngx-bootstrap 
		
	To add additional dependencies (e.g. styles):
	
		ng add ngx-bootstrap  --component componentName
		
		e.g:
		
			ng add ngx-bootstrap  --component accordion
			ng add ngx-bootstrap  --component modals
			ng add ngx-bootstrap  --component timepicker
			ng add ngx-bootstrap  --component tooltip
			
			
SEE ALSO:	https://valor-software.com/ngx-bootstrap/#/documentation#installation-instructions
			https://www.techiediaries.com/angular-bootstrap/
			https://ng-bootstrap.github.io/#/getting-started

--------------------------------------------------------------------------------------------------------------------------------------------------
Build architecture
==================
Prerequisities:
	If you want a pure, clean system delete all NPM packages from:

		Win:

			HOME\AppData\Roaming\npm\node_modules 

Install the following packages:

	npm i -g typescript
	npm i -g tslint
	npm i -g @angular/cli
	
		Typescript
		TSLint:			TSLint is an extensible static analysis tool that checks TypeScript code.
		Codelyzer:		A set of tslint rules for static code analysis of Angular TypeScript projects.

Optional:
	
	Bootstrap (4 or above):		
		
		npm install --save @ng-bootstrap/ng-bootstrap
		
		SEE ALSO:		How to add Bootstrap to an Angular project?	
		
	FontAwesome:
		Method 1 - npm:
			
			ng add @fortawesome/angular-fontawesome
	
		Method 2 - npm:
			- install:
				
				npm install @fortawesome/fontawesome-free

			- configure:
			
				add this entry to angular.json (into "styles"):
				
					"styles": [ 
						...
						"./node_modules/@fortawesome/fontawesome-free/css/all.css"
					],
				
			- usage:

				<i class="fa fa-check"></i>


			SEE ALSO:	https://fontawesome.com/how-to-use/on-the-web/setup/using-package-managers
						https://fontawesome.com/how-to-use/on-the-web/using-with/angular

--------------------------------------------------------------------------------------------------------------------------------------------------
Structure of an Angular application
===================================
- Everything is directive
- components are directives with template
- application contains a component tree, where there is one main component 

Compiled index.html contains JS references which loads main.js (compiled from main.ts) ---> <app-root>

--> main.ts bootstraps main module (e.g. AppModule)
	platformBrowserDynamic().bootstrapModule(AppModule)
	
		--> app.component.ts
			--> app.component.html
				<app-heroes>
			--> app.component.css


			
--------------------------------------------------------------------------------------------------------------------------------------------------
Bootstrapping Angular application
=================================

Development with Angulkar-CLI:

	ng serve -> angular.json -> main.ts -> @NgModule AppModule -> AppComponent

	
	Angular has a powerful concept of modules. When you boot an Angular app, you’re not booting a
	component directly, but instead you create an NgModule which points to the component you want
	to load.
	
ng serve
	• ng serve looks at .angular-cli.json which specifies main.ts as our entry point (and index.html as our index file)
	• main.ts bootstraps AppModule
	• AppModule specifies that AppComponent is the top level component
	• … and then AppComponent renders the rest of our app!

	==> angular.json
			"main": "src/main.ts"			// this is entry point
			
			It bootstraps an Angular module:			
			
				platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.log(err));
			
			==> AppModule
			
				AppModule specifies which component to use as the top-level component:
				
					bootstrap: [AppComponent]
			
--------------------------------------------------------------------------------------------------------------------------------------------------
Easy installation of development environment
============================================
- Install npm
	NPM is part of NodeJS so install NodeJS if you don't have it yet.
	
	OR

	- Update npm

		npm install npm -g

- Install Angular CLI

		
	npm install -g @angular/cli

- Create a new project

	ng new my-app

- Start app

	cd my-app
	ng serve --open
	OR
	npm start
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Data binding
============
Method 1:

	<div class="field">
		<label for="title">Title:</label>
		<input name="title" id="title" #newtitle>
	</div>
	...
	<button (click)="addArticle(newtitle, newlink)" class="ui positive right floated button">Submit link</button>

	
	export class XComponent {
		addArticle(title: HTMLInputElement, link: HTMLInputElement): boolean {
			console.log(`Adding article title: ${title.value} and link: ${link.value}`);
			return false;
		}
	}
	

Method 2:

	<li>{{hero.name}}</li>														<--
	<hero-detail [hero]="selectedHero"></hero-detail>							<--
	<li (click)="selectHero(hero)"></li>										-->
	<input [(ngModel)]="hero.name">												<-->		

	
DOM                             COMPONENT
         <-----------------                       {{v}}					:  The {{hero.name}} interpolation displays the component's hero.name property value within the <li> element.
		 
		 <-----------------                       [property]="value"	: The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to 
																			the hero property of the child HeroDetailComponent.
		 
		 ------------------>                      (event)="handler"		: The (click) event binding calls the component's selectHero method when the user clicks a hero's name.
		 
        <------------------>                       [(ngModel)]="value"	: Two-way data binding is an important for form that combines property and event binding in a single notation, 
																			using the ngModel directive.
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
What is a directive? Directive vs component
===========================================
- A directive is a class with a @Directive decorator. 
- A component is a directive-with-a-template; 
- @Component decorator is actually a @Directive decorator extended with template-oriented features. 
- While a component is technically a directive, components are so distinctive and central to Angular applications that we separate components from directives.

Two other kinds of directives exist: 
	- structural directives	: Structural directives alter layout by adding, removing, and replacing elements in DOM.
	
		<li *ngFor="let hero of heroes"></li>
		<hero-detail *ngIf="selectedHero"></hero-detail>
	
		*ngFor tells Angular to stamp out one <li> per hero in the heroes list.
		*ngIf includes the HeroDetail component only if a selected hero exists.
		
	- attribute directives	: Attribute directives alter the appearance or behavior of an existing element. 

		<input [(ngModel)]="hero.name">
		
		The ngModel directive, which implements two-way data binding, is an example of an attribute directive. 
		ngModel modifies the behavior of an existing element (typically an <input>) by setting its display value property and responding to change events.
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
How to use a service?
=====================
- Create:
		ng generate service hero
		
	OR write it manually.

- Register
	- To instantiate a service a provider should be registered.
	- In general, add providers to the root module so that the same instance of a service is available everywhere.
	- But you can register a provider in a component, too. Registering at a component level means you get a new instance of the service 
		with each new instance of that component.

	
- Import and inject
	
	- 
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to debug Angular?	
=====================
- Print out model as JSON:

	<div>{{model | json}}</div>

- Put 'debugger' command into JS:

	debugger;
	
	and browser will stop at this location.
	
	Set:	"sourceMap": true
	
		in tsconfig.ts and browser will show source TS instead of generated JS in source panel.
	
- In Chrome/Sources you can find webpack:// folder which contains a '.' subfolder 
	which contains all TS files. Here you can place debugger breakpoints.
	

- WebStorm:

		- Create 2 menu into WebStorm 'Edit Run/Debug Configuration'
			- 'npm'
				- pointing to 'start' package.json' script
			- 'JavaScript Debug'
				- URL: points to URL of Angular application 
				
				
		- Start 'npm' configuration with 'Run' and wait for compilation and start to be completed.
		- Start 'JavaScript Debug' with 'Debug'
		
		NOTE: 
			 '--evalSourceMap=true' depracated option can hurt debugger. I had it and debugger was not stopped on breakpoints.
			 Remove it.
		
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to generate components?	
===========================
General component:

	
Service:
	global:
		ng generate service hero
	module specific:
		ng generate service hero --module=app
	

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to configure TS?
====================
There are multiple tsconfig*.json in hierarchy (in inheritance):




	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to configure TSLint?
========================
TSLint is an extensible static analysis tool that checks TypeScript code for readability, maintainability, and functionality errors.
It uses Codelyzer rules for check Angular code.

Yuo can customize behavior in tslint.json, e.g. changing component selector format add:

	       "component-selector": [
            true,
            "element",
            ["app", "custom"],
            "kebab-case"
        ]
		
		
Be aware of multiple tslint.json, for example latest Angular-CLI generates 

	APP/tslint.json
	APP/src/tslint.json
	
	where src/tslint.json extends the other one.
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to get versions?
====================
Call:		ng --versions

It prints version of all important packages:

	Angular CLI: 6.0.3
	Node: 8.10.0
	OS: win32 x64
	Angular:
	...

	Package                      Version
	------------------------------------------------------
	@angular-devkit/architect    0.6.3
	@angular-devkit/core         0.6.3
	@angular-devkit/schematics   0.6.3
	@schematics/angular          0.6.3
	@schematics/update           0.6.3
	rxjs                         6.2.0
	typescript                   2.7.2


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto get usable Angular CLI functions?
=======================================
ng --help


--------------------------------------------------------------------------------------------------------------------------------------------------
How to set CSS class of host element from component code?
=========================================================
Use @HostBinding('attr.class'). It sets class of rendered element.

For example:

	@Component({
	  selector: 'app-article',
	  templateUrl: './article.component.html',
	  styleUrls: ['./article.component.css']
	})
	export class ArticleComponent implements OnInit {
		@HostBinding('attr.class') cssClass = 'row';
		....
	}
	
is the same as you would put class='row' into parent template where you use <app-article>:

	<app-article ... class='row'>




	
--------------------------------------------------------------------------------------------------------------------------------------------------
TSLint: Type ... trivially inferred from a ... literal, remove type annotation (no-inferrable-types)
====================================================================================================
If you have a member property like this:

	export class CounterComponent implements OnInit {

	  count: number = 0;
	  
	  ...
	}
	
and you have lint error as mentioned.

Problem: type declaration and value assignement is redundant.
Fix: if you have assigned value right in the property declaration remove type declaration.	

	export class CounterComponent implements OnInit {

	  count = 0;
	  
	  ...
	}

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to change the default prefix of component to stop tslint warnings
=====================================================================
Prefix of a component only appearing in template. 
Name of component in file names and in TS does NOT contain prefix.
For example:

	Prefix is:	app

	src/app/user-list
		- user-list.component.css
		- user-list.component.html
		- user-list.component.ts
		
			selector:	app-user-list
		
How to configure allowed prefixes:
	angular-cli.json/projects/prefix					: default prefix, it will be used when AngularCLI generates a new component
	tslint.json/component-selector/3rd array element	: contains 1 prefix or array of prefixes which contains permitted prefix(es)

	- If you want to change prefix to another, then change them 
	- If you want to allow multiple prefixes in change prefix in tslint.json into an array and add multiple prefixes. 
		Then set default prefix in angular-cli.json .
		
If you don't want prefixes you have to remove/comment out component-selector from tslint.json


--------------------------------------------------------------------------------------------------------------------------------------------------
How to use interpolation (template expression)?
===============================================
Double-curly braces: interpolation, iut contains template expression.
- interpolation contains an expression
- expressions access component properties directly

--------------------------------------------------------------------------------------------------------------------------------------------------
How to set component input with a literal value?
================================================
Component input binding in template receives property name and not a value directly by default.

- If you want to set an input with a string literal value directly use '...' in expression:			[input-property]="'value'"
	OR don't use input expression:																	input-property="value"

- number values are recognized automatically:														[input-property]="num-value"
	OR 																								input-property="num-value"
	
TS:
	@Component({
	  selector: 'app-my-form',
	  templateUrl: './my-form.component.html',
	  styleUrls: ['./my-form.component.css']
	})
	export class MyFormComponent implements OnInit {
	  @Input() title: string;
	  @Input() size: number;

	  constructor() {
		this.title = 'default';
		this.size = 3;
	  }

	  ngOnInit() {
	  }
	}
	
Caller template:

	<app-my-form [title]="'literal'" [size]="3.2"></app-my-form>
	OR
	<app-my-form title="literal" [size]="3.2"></app-my-form>
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to set component input with a boolean value?
================================================
If you have a component with a boolean and you try to specify property this way:

	Component:
		@Component({
		  selector: 'app-test',
		  ...
		})
		export class TestComponent implements OnInit {
		  @Input() enabled: true;
		}


	Usage:
	
		<app-test enabled="false>																	// BAD !!!!!


	...then value will be "false" string.
	
	
	YOU SHOUL always use brackets if you want to get right data type:
	
		<app-test [enabled]="false>																	// GOOD
	
	






--------------------------------------------------------------------------------------------------------------------------------------------------
Conditional or dynamic CSS Style/Class
======================================
Setting styles:
	Method 1:	The simplest way to use this directive is by doing [style.<cssproperty>]="value"
	
		<div [style.background-color]="'yellow'">
			Uses fixed yellow background
		</div>

	Method 2: Another way to set fixed values is by using the NgStyle attribute and using key value pairs for each
			property you want to set, like this:
		
		<div [ngStyle]="{color: 'white', 'background-color': 'blue'}">
			Uses fixed white text on blue background
		</div>
		
Conditional style:

	<div [ngStyle]="{'background-color': isDanger() ? '#ff0000' : 'transparent'}">		
		
		
		
Conditional class:
	<tag [class.<CSS CLASS>]='<boolean component property>'>

	For example:	Toggle background color with click.
	
	HTML:
		
		<p [class.clicked]='selected' (click)="onClick()">
		
	TS:
		
		@Component({
		  selector: 'app-css-demo',
		  templateUrl: './css-demo.component.html',
		  styleUrls: ['./css-demo.component.css']
		})
		export class CssDemoComponent implements OnInit {
		  selected: boolean = false;

		  constructor() {
			this.showTitle();
		  }

		  ngOnInit() {
		  }

		  onClick() {
			this.selected = !this.selected;
		  }
		}
		
		
	CSS:
		.clicked {
			background-color: lightgreen;
		}
		
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to add global styles with Angular CLI?	
==========================================
Add new entry to projects/.../styles generated angular.json. E.g:

	"styles": [
	  "src/assets/vendor/semantic.min.css",
	  "src/styles.css"
	],

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to deploy for production?
=============================

	ng build --target=production --base-href /

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to access angular-cli server from external host?
====================================================
It opens server on public interface:

	ng serve --host <local-host-ip>
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to specify default port (4200) of angular-cli server?
=========================================================
- In the new angular.json you now specify a port per "project"

	"projects": {
		"my-cool-project": {
			... rest of project config omitted
			"architect": {
				"serve": {
					"options": {
						"port": 4201
					}
				}
			}
		}
	}

- OR in command line:

	ng serve --port 4201
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to use forms
================
Under the hood form management needs FormGroup and FormControls object.
- EITHER use it implicitely (template driven mode)
- OR bind an existing one into template (model driven mode)

Form management based on a common ancestor class:
	AbstractControl
		- value
		- valid / invalid
		- touched
		- errors
		- pristine (true: not changed yet in UI)
		- dirty (true: changed in UI)
		- ...

	Which has 2 inherited class:
	- A FormControl represents a SINGLE INPUT FIELD - it is the smallest unit of an Angular form.
			
		// create a new FormControl with the value "Nate"
		let nameControl = new FormControl("Nate");
		let name = nameControl.value; // -> Nate
		
		// now we can query this control for certain values:
		nameControl.errors // -> StringMap<string, any> of errors
		nameControl.dirty // -> false
		nameControl.valid // -> true

	- FormGroup: manages MULTIPLE FormControls

		let personInfo = new FormGroup({
			firstName: new FormControl("Nate"),
			lastName: new FormControl("Murray"),
			zip: new FormControl("90210")
		})

		// now we can query this control group for certain values, which have sensible
		// values depending on the children FormControl's values:
		personInfo.errors // -> StringMap<string, any> of errors
		personInfo.dirty // -> false
		personInfo.valid // -> true
				
	
- 2 approaches:
	
	1. Template driven (FormControls are in template):
	==================================================
	You setup your form in the template (HTML) and Angular automatically infer the structure 
	of your form.
	
	Ho to use it?
	-------------
	- import FormsModule
	- add 'ngModel' to input tags to select input data
	- add 'name' to input tags to specify input data name
	- add a submit handler into controller e.g: onSubmit()
	- add (ngSubmit)="onSubmit(...)" event to <form>
	- add a local reference to ngForm directive of form, e.g: #f="ngForm"
	- EITHER 
		- pass this local reference to submit handler: (ngSubmit)="onSubmit(#f)"
		- and add reference to submit handler: onSubmit(form: NgForm)
	- OR
		- refer local reference with @ViewChild
		- don't pass it as argument
	- submitted value is a JS object which contains a lot of information about input form (values, controls, dirty, disabled, errors, ...)
	- add validator to template 
		- 'required' : standard HTML attribute recognized by Angular
		
		
		SEE ALSO:	https://angular.io/guide/forms
	
		The FormsModule gives us template driven directives such as:
		• ngForm and
		• ngModel
		
			template:
			
			  <form #f="ngForm"									<<< ngForm ---> 'f' local variable
					(ngSubmit)="onSubmit(f.value)"				<<< ngSubmit: output event on submit
					class="ui form">

				<div class="field">
				  <label for="skuInput">SKU</label>
				  <input type="text"
						 id="skuInput"
						 placeholder="SKU"
						 name="sku" 
						 ngModel						<<< ngModel: it builds a FormControl and associates this field to f.value.sku
						 required						 <<< validator is in the template
					>
				</div>
				<button type="submit" class="ui button">Submit</button>
			  </form>
		
			controller:
			
			  onSubmit(form: NgForm): void {
				console.log('you submitted value:', form);
			  }

		- NgForm does something handy but non-obvious: it includes the form tag in its selector (instead
			of requiring you to explicitly add ngForm as an attribute). What this means is that if you import
			FormsModule, NgForm will get AUTOMATICALLY attached to any <form> tags you have in your view.

		- The #v=thing syntax says that we want to create a local variable for this view.
			
			<form #f="ngForm" (ngSubmit)="onSubmit(f.value)"		  
			  
		- When we use ngModel with no attribute value we are specifying:
			1. a one-way data binding
			2. we want to create a FormControl on this form with the name sku (because of the name attribute on the input tag)
			
		- There are two important pieces of functionality that NgForm gives us:
			1. A FormGroup named ngForm		
			2. A (ngSubmit) output
				
				NgForm.
					- control: FormGroup (which has the same properties: controls, value, status, touched, ...)
					- controls: disctionary of FormControls
					- value: object with values
					- status
					- ...
			
	How to set input values of fields?
	----------------------------------
	change ngModel to [ngModel]="..." (one way binding)
			
	2. Model driven / Reactive (FormControls are in controller):
	============================================================
	You actually define the structure of the form in TS code and then yo create HTML template and 
	then you manually connect them.
	
		SEE ALSO:	https://angular.io/guide/reactive-forms
	
		• formGroup and
		• formControl
	

	Ho to use it?
	-------------
		- create a FormGroup property in controller (a group of FormControllers)
		- import  ReactiveFormsModule (and you DON'T need the FormsModule)
		- create form controls in controller. FormGroup is an object where field names are the property keys.
		- add validators to FormControl in the controller
		
		method 1 - manually:
			controller:
				signupForm: FormGroup;
				
				ngOnInit() {
					this.signupForm = new FormGroup({							<<<< group of FormControls
						'username': new FormControl('default username');			
						'email': new FormControl(null);
						'gender': new FormControl('male');
					});
				}
				
			template:
				<form [formGroup]="signupForm" (ngSubmit)="onSubmit()>						<<<< bind template form and FormGroup
					<input 
						type="text" 
						formControlName="username"				<<<< bind input to FormControllers
					>
					<input 
						type="text" 
						formControlName="email"				<<<< bind input to FormControllers
					>
				</form>
			
			
		method 2 - using form builder:
			template:
			
			  <form [formGroup]="myForm" (ngSubmit)="onSubmit()">				<<< don't send form to controller, since it's there
				<div class="field">
				  <label for="skuInput">SKU</label>
				  <input type="text" id="skuInput" placeholder="SKU" [formControl]="myForm.controls['sku']">					<<< v1
				  <span *ngIf="!myForm.get('sku').valid && !myForm.get('sku').touched">Please enter a valid SKU</span>			<<< FormControl.get('NAME | PATH')  : path for nested controls (into FormGroup)
				</div>
				
				<div class="field">
				  <label for="skuDesc">Description</label>
				  <input type="text" id="skuDesc" placeholder="Description" formControlName="desc">		<<< v2
				</div>
				
				<button type="submit" class="btn btn-primary">Submit</button>
			  </form>
				
			controller:
			
				export class DemoFormSkuWithBuilderComponent implements OnInit {
				  myForm: FormGroup;													<<< form group

				  constructor(fb: FormBuilder) {
					this.myForm = fb.group({
					  'sku': ['ABC123', [Validators.required]],					<<< validator is in the controller FormControl
					  'desc': ['']
					});
				  }

				  ngOnInit() {
				  }

				  onSubmit(): void {
					const value = this.myForm.value;
					console.log('you submitted values - SKU:', value.sku + ' description:' + value.desc);
				  }
				}
			
		- During injection an instance of FormBuilder will be created and we assign it to the fb variable (in the constructor).
		- There are two main functions we’ll use on FormBuilder:
			• control - creates a new FormControl
			• group - creates a new FormGroup
	
	
	==================================== TROUBLESHOOTING TIP =====================================
	'class' attributes of input element managed by Angular. 'ng-...' classes contain state information of 
		- ng-dirty
		- ng-valid
		- ng-touched
		- ...
		
	- Angular sets these classes dynamically during navigating on form.
	
	================================== REMEMBER ==================================
	
		To create a new FormGroup and FormControls implicitly use (template driven):
			• ngForm and
			• ngModel
			
		But to bind to an existing FormGroup and FormControls use (model driven):
			• formGroup and
			• formControl
			
	==============================================================================
	
	SEE ALSO:
		https://angular.io/guide/forms-overview
		https://www.tektutorialshub.com/angular/angular-forms-fundamentals/
		How Angular store Form and FormControl state information to CSS class?
		
--------------------------------------------------------------------------------------------------------------------------------------------------
How to prevent adding NgForm to forms automatically?
====================================================
SEE ALSO:
	Using forms
	
Remember how earlier we said that when using FormsModule that NgForm will be AUTOMATICALLY
applied to a <form> element? 

There is an exception: NgForm won’t be applied to a <form> that has formGroup.

If you’re curious, the selector for NgForm is:

	form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]
	
This means you could have a form that doesn’t get NgForm applied by using the ngNoForm attribute:

	<form ngNoForm>
		...
	</form>
	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Can't bind to 'formControl' since it isn't a known property of 'input'
=============================================================================
You are using Reactive form but you forgot 
	- to import ReactiveFormsModule into main module 
	OR
	- to add ReactiveFormsModule to 'imports' of @NgModule

	
	import { ReactiveFormsModule } from '@angular/forms';
	...
	
	@NgModule({
	  imports:      [ ReactiveFormsModule ],
	  ...
	})	 

--------------------------------------------------------------------------------------------------------------------------------------------------
How to trace value of  Reactive form?
=====================================
You can access values 

Print to template with JSON pipe:

	<h5>Form value: {{form.value | json}}</h5>


--------------------------------------------------------------------------------------------------------------------------------------------------
How to control form UI by validation status?
============================================

- Disable submit button if form is not valid:

	<button type="submit" [disabled]="!form.valid">OK</button>


--------------------------------------------------------------------------------------------------------------------------------------------------
How to check empty values in interpolations?
============================================
In ngIf simply use variable (it can be non-boolean, too - eg. object, string, ...):

	<span *ngIf="errorMsg" style="background-color: red">{{errorMsg}}</span>

	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Unexpected token } in JSON at position ...
=================================================
Check angular.json for sytax error(s).



--------------------------------------------------------------------------------------------------------------------------------------------------
How to access DOM elements from a controller?
=============================================
- template reference variable

	<form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... </form>

	
-  template input variable:	
	
	
	<button *ngFor="let hero of heroes" (click)="deleteHero(hero)">{{hero.name}}</button>
	
-	@ViewChild:

	<input #myname>
	
	@ViewChild('myname') input; 
	
	ngAfterViewInit() {
	  console.log(this.input.nativeElement.value);
	}


	
--------------------------------------------------------------------------------------------------------------------------------------------------
Attribute binding
=================
<tr><td colspan="{{1 + 1}}">Three-Four</td></tr>

And you get this error:

	Template parse errors:
	Can't bind to 'colspan' since it isn't a known native property
	
Why? 
As the message says, the <td> element does not have a colspan property. It has the "colspan" ATTRIBUTE, but INTERPOLATION AND PROPERTY BINDING CAN SET ONLY PROPERTIES, NOT ATTRIBUTES.	
You need attribute bindings to create and bind to such attributes:

	 <tr><td [attr.colspan]="1 + 1">One-Two</td></tr>


--------------------------------------------------------------------------------------------------------------------------------------------------
Property binding or interpolation?
==================================
They do the same - but with interpolation and property binding:
	
	<p><img src="{{heroImageUrl}}"> is the <i>interpolated</i> image.</p>
	<p><img [src]="heroImageUrl"> is the <i>property bound</i> image.</p>

	<p><span>"{{title}}" is the <i>interpolated</i> title.</span></p>
	<p>"<span [innerHTML]="title"></span>" is the <i>property bound</i> title.</p>	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Class binding
=============
-  all-or-nothing, replacement binding with string literal:

	<div class="bad curly special" [class]="badCurly">Bad curly</div>
	
- add/remove class with boolean expression:

	<div [class.special]="isSpecial">The class binding is special</div>
	

--------------------------------------------------------------------------------------------------------------------------------------------------
Style binding
=============
You can set inline styles with a style binding [style.style-property]:

	<button [style.color]="isSpecial ? 'red': 'green'">Red</button>
	<button [style.background-color]="canSave ? 'cyan': 'grey'" >Save</button>
	<button [style.font-size.em]="isSpecial ? 3 : 1" >Big</button>
	<button [style.font-size.%]="!isSpecial ? 150 : 50" >Small</button>


--------------------------------------------------------------------------------------------------------------------------------------------------
Event binding
=============
Event binding syntax consists of a TARGET EVENT name within parentheses on the left of an equal sign, and a quoted TEMPLATE STATEMENT on the right.
	
	<button (click)="onSave()">Save</button>
	


--------------------------------------------------------------------------------------------------------------------------------------------------
Parent-child component interaction
==================================
PARENT =======> CHILD

	- Pass data from parent to child with input binding

		parent:
			<app-hero-child *ngFor="let hero of heroes" [hero]="hero"></app-hero-child>
			
		child:
			selector: 'app-hero-child',
			@Input() hero: Hero;


	- Intercept input property changes with a setter

		Same as 'Pass data from parent to child with input binding' but with a setter.

		parent:
			<app-name-child *ngFor="let name of names" [name]="name"></app-name-child>
		
		child:
			@Input()
			set name(name: string) {
				this._name = (name && name.trim()) || '<no name set>';
			}

	- Intercept input property changes with ngOnChanges()
		parent:
			app-version-child [major]="major" [minor]="minor"></app-version-child>

		child:
			export class VersionChildComponent implements OnChanges {

				ngOnChanges(changes: {[propKey: string]: SimpleChange}) {
					// propKey contains changed property
				}
			}

CHILD =======> PARENT
	
	- Parent listens for child event

		child:
			selector: 'app-voter',
			@Output() voted = new EventEmitter<boolean>();
			
			vote(agreed: boolean) {
				this.voted.emit(agreed);
			}
	
		parent:
			<app-voter *ngFor="let voter of voters" (voted)="onVoted($event)"></app-voter>		
	
	
	- Parent interacts with child via local variable
		parent:
			<button (click)="timer.start()">Start</button>
			<button (click)="timer.stop()">Stop</button>
			<div class="seconds">{{timer.seconds}}</div>
			<app-countdown-timer #timer></app-countdown-timer>

		child:
			selector: 'app-countdown-timer'
			
			seconds: number;
			start() { this.countDown(); }
			stop()  {
				this.clearTimer();
				this.message = `Holding at T-${this.seconds} seconds`;
			}		
			
	- Parent calls an @ViewChild()
		The local variable approach is simple and easy. But it is limited because the parent-child wiring must 
		be done entirely within the parent template. The parent component itself has no access to the child.
		
		parent:
			@ViewChild(CountdownTimerComponent)
			private timerComponent: CountdownTimerComponent;			

		child:
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------
How works component level CSS?
==============================
.....
.....
.....

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Null check on objects
=====================
Example:		<span class="subhead">{{project?.category}}</span>

? is the safe navigation operator. 
It checks whether the variable is null or undefined so that our template won't try to select a property of something falsy.

Without ? operator if 'project' is null an error will generated:

	TypeError: Cannot read property 'category' of null in [null].


--------------------------------------------------------------------------------------------------------------------------------------------------
How to prototype test Rest services?
==============================
https://jsonplaceholder.typicode.com/

- create a repository in GitHub
- create db.json into repository with the content like this:

{
    "posts": [
        {
            "id": 1,
            "title": "Post 1"
        },
        {
            "id": 2,
            "title": "Post 2"
        },
        {
            "id": 3,
            "title": "Post 3"
        }
    ],
    "person": [
        {
            "id": 1,
            "name": "John Smith",
            "gender": "M"
        },
        {
            "id": 2,
            "name": "Jane Doe",
            "gender": "F"
        }
    ],   
    "comments": [
        {
            "id": 1,
            "body": "some comment",
            "postId": 1
        },
        {
            "id": 2,
            "body": "some comment",
            "postId": 1
        }
    ],
    "profile": {
        "name": "typicode"
    }
}


TIP:
	- changes not updated immediately, maybe a few of minutes later 
	
		After changing db.json check changes with:
	
			https://my-json-server.typicode.com/<user>/<repo>/db
		

--------------------------------------------------------------------------------------------------------------------------------------------------
Property 'map' does not exist on type 'Observable<...>'
=======================================================
For versions of RxJS 6.x.x and above, you will have to use pipeable operators as shown in the code snippet below:

	import { map } from 'rxjs/operators';
	import { HttpClient } from '@angular/common/http';

	// ...
	export class MyComponent {
	  constructor(private http: HttpClient) { }
	  getItems() {
		this.http.get('https://example.com/api/items').pipe(map(data => {})).subscribe(result => {
		  console.log(result);
		});
	  }
	}
	
	
operators: Pipeable operators must now be imported from rxjs like so: 

	import { map, filter, switchMap } from 'rxjs/operators';
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to set browser title?	
=========================
Use Title service:

	import {Title} from '@angular/platform-browser';
	...

	public constructor(titleService: Title ) {
		titleService.setTitle(this.title);
	}

	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'
==========================================================================
EXPLANATION
-----------
	In order to use the new forms library we need to first make sure we import the forms library in our
	NgModule.

		import {
			FormsModule,
			ReactiveFormsModule
		} from '@angular/forms';
		
		...
		@NgModule({
			declarations: [
				...
			],
			imports: [
				BrowserModule,
				FormsModule, 						// <-- add this
				ReactiveFormsModule 				// <-- and this
			],
			...
		})
		class FormsDemoAppModule {}

	This ensures that we’re able to use the form directives in our views. At the risk of jumping ahead,
	the FormsModule gives us template driven directives such as:

		• ngModel and
		• NgForm
		
	whereas ReactiveFormsModule gives us model driven directives like

		• formControl and
		• ngFormGroup

COUSE
-----
	If you build a reactive (model driven) form, like this:

		<form class="section" [formGroup]="form" (ngSubmit)="onSubmit()">
			...
		</form>
		
	, but you forget import ReactiveFormsModule into your (app) module
	these directives won't be added to <form> tags.
		

--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: No provider for ControlContainer ("[ERROR ->]<form...
============================================================
SEE ALSO:	ERROR: Can't bind to 'formGroup' since it isn't a known property of 'form'

Similarly to previous problem:
	If you have a (non-reactive) form but you forget to add
		
		FormsModule
		
	to your (app) module then you will get this error.
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Uncaught Error: Unexpected directive '...' imported by the module '...'. Please add a @NgModule annotation
=================================================================================================================
This error frequently comes up when we are not importing, providing, or declaring the angular modules, services, 
components properly.

Make sure that we should only

	- import modules and not the components or services
	- declare components and not the modules or services.
	- provide services and not components or modules.


--------------------------------------------------------------------------------------------------------------------------------------------------
How to bind an event observable to an HTTP element?
===================================================
1. Add # element reference to elent

2. Bind this reference into TS with @ViewChild

3. Create observable in ngAfterViewInit with fromEvent(...), use nativeElement of HTML element reference.

View:

	<span #clickTarget>Click here to ...</span>

TS:
	@ViewChild('clickTarget') clickTarget: ElementRef;

	ngAfterViewInit(): void {
		fromEvent(this.clickTarget.nativeElement, 'click').pipe(
		  tap(() => console.log('Clicked --> start processing')),
		  concatMap(this.startLongProcessing)
		).subscribe(
		  (evt) => console.log('event: ' + evt),
		  noop,
		  () => console.log('----------- processing completed -----------------')
		);
	}


--------------------------------------------------------------------------------------------------------------------------------------------------
How to interpolate enum values in template?
===========================================
Add reference pointing to enum as member ito class and you will be able to access from template:

TS:
	enum FlatteningType {
	  MERGE = 'merge',
	  SWITCH = 'switch',
	  CONCAT = 'concat',
	  EXHAUST = 'exchaust'
	}

	export class FlatteningComponent implements OnInit, AfterViewInit {
		...
		flatteningTypeEnum = FlatteningType;
		...
	}

HTML:

	<input type="radio" id="flattMerge" name="flatteningType" [(ngModel)]="flatteningType" value="{{flatteningTypeEnum.MERGE}}">
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.	
=======================================================================================================
??????????????????


--------------------------------------------------------------------------------------------------------------------------------------------------
Lifecycle Hooks
===============
Lifecycle hooks are:
	- ngOnChanges					: ngOnChanges called BEFORE ngOnInit() and WHENEVER one/more data-bound input properties change.
										It means, whenever any input properties changed than the code under this function will be triggered
										
	- ngOnInit						: ngOnInit is there to give us a signal that Angular has finished initializing
	
	- ngDoCheck						:  it’s called WHENEVER any changes during the app execution happened.
										In addition, it’s called IMMEDIATELY AFTER ngOnChange and ngOnInit.
	
	- ngAfterContentInit
	- ngAfterContentChecked
	- ngAfterViewInit
	- ngAfterViewChecked
	- ngOnDistroy
	

SEE ALSO:
	https://angular.io/guide/lifecycle-hooks
	Angular-4-Lifecycle-Hooks-Overview.jpg


--------------------------------------------------------------------------------------------------------------------------------------------------
How to analyze/update package versions?		
=======================================
- To analyze package versions:

	ng update
	
	
		We analyzed your package.json, there are some packages to update:

		  Name                               Version                  Command to update
		 --------------------------------------------------------------------------------
		  rxjs                               6.3.3 -> 6.5.2           ng update rxjs

	
	
	
	
- To update a package:

	ng update <package>
	
	as recommended from table.
	
- To update all:

	ng update --all
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Schematics
==========
- A schematic is a template-based code generator.
- Schematics are packaged into COLLECTIONS and installed with npm.
- Schematics that are included in the 

		@schematics/angular 
		
	collection are run BY DEFAULT by the commands ng generate and ng add. 

-  You can specify a particular schematic (or collection of schematics) to generate, using the long form:
	
	ng generate my-schematic-collection:my-schematic-name

  OR
  
	ng generate my-schematic-name --collection collection-name	
	
- To get available schematics:

		ng generate --help


--------------------------------------------------------------------------------------------------------------------------------------------------
How to set default schematics collection?
=========================================
If you want to call a schematic from a non-default colection the syntax is:

	ng generate my-schematic-collection:my-schematic-name


Call this command in a project:
				
	ng config cli.defaultCollection @ngrx/schematics

Running this command adds the following to the angular.json file:

	"cli": {
		"defaultCollection": "@ngrx/schematics"
	}

	
Without this you from 	
	
	
After this 	you will be able to call schematics from default collection without collection name:

	
	ng generate my-schematic-name
	
  OR
		
	ng g my-schematic-name
	

--------------------------------------------------------------------------------------------------------------------------------------------------
How to navigate from a controller code?
=======================================
- inject router 

  constructor(private router: Router, ...) { }
	

- call:

	this.router.navigateByUrl(url);
	OR
	this.router.navigate(commands);

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Howto use boolean observable with async pipe and ngIf?
======================================================
You have a boolean observable in a component:

	main.component.ts:
	
		export class MainComponent implements OnInit {
			isLoggedIn$: Observable<boolean>;
			...
		}
	
To render the true value is trivial, just use async pipe.
But what about false? Evaluate it and compare with 'false'.

	main.component.html:
	
		<div class="container mt-2">
		  <ngrx-login *ngIf="(isLoggedIn$ | async) === false"></ngrx-login>
		  <ngrx-logout *ngIf="isLoggedIn$ | async"></ngrx-logout>
		</div>

--------------------------------------------------------------------------------------------------------------------------------------------------
i18n
====
Steps
-----
	1. add i18n (i18n-*) tag to your template tags (properties)
	
		i18n="meaning|description@@id"
		
		For example:
		
			<h1 i18n="main title">This is a title text</h1>
			<h1 i18n="@@mainTitle">This is a title text</h1>
	
	2. call 'xi18n' to generate locale files, e.g:
	
		ng xi18n --output-path locale
	
		The command can read and write files in three translation formats:
			- XLIFF 1.2 (default)
			- XLIFF 2
			- XML Message Bundle (XMB)
			
		You can specify the translation format explicitly with the --i18nFormat command option, as illustrated in these example commands:


			ng xi18n  --i18n-format=xlf
			ng xi18n  --i18n-format=xlf2
			ng xi18n  --i18n-format=xmb
	
	3. (Optional) You can specify the base locale of your app with the --i18n-locale command option (default: en):
	
		ng xi18n  --output-path locale --i18n-format=xlf --i18n-locale en
		
		The extraction tool uses the locale to add the app locale information into your translation source file. 
		This information is not used by Angular, but external translation tools may need it.
	
	4. 	Translate
	
	5. Copy back:
		- Rename the translated file. Add locale ID (e.g.: messages.fr.xlf for the French language translation).
		- Put the copy in the locale folder.

Translation in detail
---------------------
	

Rules
-----
	-  Don't call private methods, fields or properties from the HTML
	
		When compiling the *.ts code to *.js, AOT refuse to connect non-public members with the HTML template.

	In detailed:
		
		For a given component all its members (methods, properties) accessed by its template must be public in the AOT compilation scenario.
		This is due to the fact that a template is turned into a TS class. A generated class and a component are 2 separate classes now and 
		you can't access private members cross-class.		

		
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Uncaught Error: Can't resolve all parameters for ...
===========================================================
Can be generated when:
- missing @Injectable decorator in service.ts file
- you have added constructor parameters to service

--------------------------------------------------------------------------------------------------------------------------------------------------
Change detection
================
SEE ALSO:
	https://medium.com/@bencabanes/angular-change-detection-strategy-an-introduction-819aaa7204e7
	https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/
	https://blog.nrwl.io/essential-angular-change-detection-fe0e868dcc00
	https://blog.angular-university.io/onpush-change-detection-how-it-works/
	https://netbasal.com/optimizing-the-performance-of-your-angular-application-f222f1c16354
	
- Change Detection means updating the view (DOM) when the data has changed.
	2 steps:
	- Update the application model (developer);
	- Reflect the state of the model in the view (Angular).
	
- Angular provides you 2 Change Detection Strategies:
	1. default
	2. onPush
	
##############################################################################################################
By default, Angular runs change detection ON ALL COMPONENTS EVERY TIME SOMETHING CHANGES IN YOUR APP 
— from a click event to data received from an ajax call. ( user events, timers, xhr, promises, etc. )	
##############################################################################################################	
		
	
1. Default
----------
By default, Angular makes no assumption on what the component depends upon. 
So it has to be conservative and will checks EVERY TIME SOMETHING MAY HAVE CHANGED, this is called DIRTY CHECKING. 

In a more concrete way, it will perform checks for:
	- each browser events
	- timers
	- XHRs (HTTP responses)
	- promises
	- pushed data
	
2. onPush
---------
It will rely ONLY on the change of the:
	- input reference changes
	- some events triggered by itself (the component) or one of its children
	- or the use of the async pipe in the template
	- lastly, you, the developer, can ask explicitly Angular to do it with the detectChanges() / tick() / markForCheck()
		for example:
	
		componentRef.markForCheck()
		
		
	When using OnPush detectors, then the framework will check an OnPush component 
		- when any of its input properties changes, 
		- when it fires an event, 
		- or when an Observable fires an event
		
		BUT NOT:
		- HTTP (xhr)
		
		
Who triggers change detection?
------------------------------
Angular at startup time will patch several low-level browser APIs.
In fact, a lot of browser APIs are patched by Zone.js to transparently trigger Angular change detection, 
such as:

	- addEventListener()
	- all browser events (click, mouseover, keyup, etc.)
	- setTimeout() and setInterval()
	- Ajax requests
	- Websockets
	
Example of patch:

	function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
		
        // and then run Angular-specific functionality
        var changed = angular2.runChangeDetection();
         if (changed) {
             angular2.reRenderUIPart();
         }
     });
	}		

How does it detect changes?
---------------------------
- By default, Angular Change Detection works by checking if the value of template expressions have changed. This is done for all components.
- By default, Angular does not do deep object comparison to detect changes, it only takes into account properties used by the template.

--------------------------------------------------------------------------------------------------------------------------------------------------
How to use environment variables?
=================================
- add your wariables to:

	src/environments/environment.ts
	AND
	src/environments/environment.prod.ts

- import environment.ts into controller:

	import {environment} from '../../environments/environment';
	
	NOTE: In productive mode it will be replaced with file environment.prod.ts.

- if you want to use it also in template add a member variable:

		env = environment;
	
	AND use it in template:
	
		<div class="d-flex flex-column h-100" *ngIf="!env.production">
			...
		</div>


		
--------------------------------------------------------------------------------------------------------------------------------------------------
Why called change detection 2x in developer mode?
=================================================
In prod mode the change detection should happen just ONCE per trigger (ApplicationRef#tick). 
In dev mode it should happen TWICE.

Angular utilizes Zones.js to know when an event is fully processed by patching some async APIs like (addEventHandler, setTimeout, ...) 
and then runs change detection AFTER EACH EVENT.

In dev mode Angular does AN ADDITIONAL CHANGE DETECTION RUN, just after the first one. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to test HTTPS(SSL) in development environment?
==================================================

	ng serve -ssl
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: '...' is not a known element
===================================
These are the 5 steps I perform when I got such an error.

	- Are you sure the name is correct? (also check the selector defined in the component)
	- Declare the component in a module?
	
		Does 'declarations' of module class decoration contains?
		
	- If it is in another module, export the component?
	- If it is in another module, import that module?
	- Restart the cli (F5)?

Other rules:
	- You can't declare a component twice. 
	- You should declare and export your component in a new separate module. 
	- Next you should import this new module in every module you want to use your component.

	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Templating expressions
======================
Angular executes the expression and assigns it to a property of a binding target; the target could be 
	- an HTML element
	- a component
	- a directive
	
Expression context (where it's evaluating) is typically the component instance.
	
- interpolation
	A template expression produces a value and appears within the double curly braces, {{ }}.

	{{ expression }}
	

- property binding
	In the property binding, a template expression appears in quotes to the right of the = symbol.
	
	[property]="expression".

		
--------------------------------------------------------------------------------------------------------------------------------------------------
Templating - structural directives
==================================
- Structural directives are easy to recognize. An asterisk (*) precedes the directive attribute name as in this example.
- What is '*' prefix?

	 Internally, Angular translates the *ngIf attribute into a <ng-template> element, wrapped around the host element, like this:
	 
	 
For example *ngIf:
	HTML:
		
		<div *ngIf="hero" class="name">{{hero.name}}</div>
	
	UNDER THE HOOD:
		- The *ngIf directive moved to the <ng-template> element where it became a property binding, [ngIf].
		- The rest of the <div>, including its class attribute, moved inside the <ng-template> element.		
	
		<ng-template [ngIf]="hero">
			<div class="name">{{hero.name}}</div>
		</ng-template>
			
			
NgIf, NgFor, and NgSwitch use the same pattern under the hood.

			
--------------------------------------------------------------------------------------------------------------------------------------------------
ng-template directive
=====================
- The <ng-template> is an Angular element for rendering HTML. 
- It is NEVER displayed directly. In fact, before rendering the view, Angular replaces the <ng-template> and its contents with a comment.
- Without structural directive the wrapped elements disappear.

Common use of ng-template:

	- ngIf/else:
	
		<div class="lessons-list" *ngIf="lessons else loading">
			... 
		</div>

		<ng-template #loading>
			<div>Loading...</div>
		</ng-template>

	UNDER THE HOOD happens:
	
		<ng-template [ngIf]="lessons" [ngIfElse]="loading">
		   <div class="lessons-list">
			 ... 
		   </div>
		</ng-template>

		<ng-template #loading>
			<div>Loading...</div>
		</ng-template>	
		
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
ng-content directive
====================
Dynamic content. That is the simplest way to explain what ng-content provides. 
You use the <ng-content></ng-content> tag as a placeholder for that dynamic content, 
then when the template is parsed Angular will replace that placeholder tag with your content. 

Component <add-button>:

		<button (click)="add()">
			<ng-content></ng-content>
		</button>


Usage of component:

		<add-button>
			Add new item
			
		</add-button>
		

SEE ALSO:
https://medium.com/@joshblf/wtf-is-ng-content-8382b2a664e1
https://www.freecodecamp.org/news/everything-you-need-to-know-about-ng-template-ng-content-ng-container-and-ngtemplateoutlet-4b7b51223691/


--------------------------------------------------------------------------------------------------------------------------------------------------
How to project content from parent to child component?
======================================================		
SEE ALSO:	ng-content directive		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Can't have multiple template bindings on one element		
===========================================================
It's not possible to apply two structural directives to the same element. 
For example this:

	<div class="lesson" *ngIf="lessons" *ngFor="let lesson of lessons">
		<div class="lesson-detail">
			{{lesson | json}}
		</div>
	</div>  

To fix this:

	<div *ngIf="lessons">
		<div class="lesson" *ngFor="let lesson of lessons">
			<div class="lesson-detail">
				{{lesson | json}}
			</div>
		</div>
	</div>		

How to avoid extra element? 
SEE: ng-container directive


The same solution without using extra <div>:

	<ng-container *ngIf="lessons">
		<div class="lesson" *ngFor="let lesson of lessons">
			<div class="lesson-detail">
				{{lesson | json}}
			</div>
		</div>
	</ng-container>
	
--------------------------------------------------------------------------------------------------------------------------------------------------
ng-container directive	
======================
You cannot specify more than 1 structural directive (* prefix) in a DOM element.
For example you cannot us *ngIf and *ngFor in the same element. 
Solution: put *ngFor element into a parent element with *ngIf.
But this way you need an extra element. Don't you?

Is there a way to apply a structural directive to a section of the page 
without having to create an extra element?

- Yes and that is exactly what the ng-container structural directive allows us to do!

	<ng-container *ngIf="lessons">
		<div class="lesson" *ngFor="let lesson of lessons">
			<div class="lesson-detail">
				{{lesson | json}}
			</div>
		</div>
	</ng-container>
	
- There is another major use case for the ng-container directive: 
	it can also provide a placeholder for injecting a template dynamically into the page.
	
	<ng-container *ngTemplateOutlet="loading"></ng-container>
	
	
- You can even inject a template into a componenent:

	PARENT:
		@Component({
		  selector: 'app-root',
		  template: `      
		<ng-template #customTabButtons>														
			<div class="custom-class">
				<button class="tab-button" (click)="login()">
				  {{loginText}}
				</button>
				<button class="tab-button" (click)="signUp()">
				  {{signUpText}}
				</button>
			</div>
		</ng-template>
		<tab-container [headerTemplate]="customTabButtons"></tab-container>      		<<<<<<<<< inject
		`})
		export class AppComponent implements OnInit {

		}


	CHILD: 
		@Component({
			selector: 'tab-container',
			template: `
			
		<ng-template #defaultTabButtons>
			
			<div class="default-tab-buttons">
				...
			</div>
			
		</ng-template>
		<ng-container 
		  *ngTemplateOutlet="headerTemplate ? headerTemplate: defaultTabButtons">
			
		</ng-container>
		... rest of tab container component ...
		`})
		export class TabContainerComponent {
			@Input()
			headerTemplate: TemplateRef<any>;							<<<<<< inject
		}

--------------------------------------------------------------------------------------------------------------------------------------------------
ngTemplateOutlet
================
If you have a template reference you can use it with ngTemplateOutlet <ng-template>


	<ng-container *ngTemplateOutlet="loading"></ng-container>
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Howto inject a template into a component (template reference)?
==============================================================
Similarly to a DOM element you can create a reference pointing to a template:

	Template:
	
		<ng-template #defaultTabButtons>
			...
		</ng-template>

	Class:
	
		@ViewChild('defaultTabButtons')
		private defaultTabButtonsTpl: TemplateRef<any>;
		

A template reference can be inject into child component with input property:

	@Input()
	headerTemplate: TemplateRef<any>;

How you can use a template reference?

	 - ngIf/else:
	 
		<div class="lessons-list" *ngIf="lessons else loading">				<<< using template reference
		  ... 
		</div>

		<ng-template #loading>												<<< template reference
			<div>Loading...</div>
		</ng-template>	 
		
	- ng-container:
	
		<ng-container *ngTemplateOutlet="loading"></ng-container>			<<< using template reference

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to use ngModel?	
===================
- It creates a single FormControl instance from a domain model and binds it to a form control element.
- 'FormsModule' should be imported to current module.

Options:
- ngModel: (no binding) to tell Angular that input is a form control

- [ngModel] : (one-way binding) If you have a one-way binding to ngModel with [] syntax, changing the value of the domain model in the component class sets the value in the view.
				For example to set default value of input field.
	
- [(ngModel)] : (two-way binding - also known as 'banana-box syntax'), the value in the UI always syncs back to the domain model in your class.
		
		
- If you want to export the properties of the associated FormControl (like validity state), export the directive into a local template variable using ngModel 
	as the key (ex: #myVar="ngModel"). 
	
	
Example howto use ngModel on a standalone control:
	
		import {Component} from '@angular/core';

		@Component({
		  selector: 'example-app',
		  template: `
			<input [(ngModel)]="name" #ctrl="ngModel" required>						

			<p>Value: {{ name }}</p>
			<p>Valid: {{ ctrl.valid }}</p>											<<<<<<<<<<< accessing associated FormControl
			
			<button (click)="setValue()">Set value</button>
		  `,
		})
		export class SimpleNgModelComp {
		  name: string = '';

		  setValue() {
			this.name = 'Nancy';
		  }
		}	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Validation hints
================
- Validation handled by Angular automatically
- Validation flags generated by form and formControl level in NgForm
- Validation flags are managed automatically by Angular during navigating on form. 
- Built-in validators:  https://angular.io/api/forms/Validators

SEE MORE: 
	How Angular store Form and FormControl state information to CSS class
	https://angular.io/api/forms/Validators
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How Angular store control state information to CSS class?
=========================================================
Control state flags are managed by Angular dynamically during navigating on form.
Flags are provided for:
- form
- form controls
- form control groups

Flags are written into CSS class of forms and input fields (form controls) and wrapper divs (with ngModelGroup) as 'ng-..' values:

	ng-valid		: The field content is valid
	ng-invalid 		: The field content is not valid
	ng-pending		: waitng for async validation (?)
	ng-dirty		: The field has been modified
	ng-dirty		: The field has been modified
	ng-untouched	: The field has not been touched yet
	ng-touched		: The field has been touched
	
For example after page load 
	- form class is:		ng-untouched ng-pristine ng-invalid
	- input class is:		form-control ng-untouched ng-pristine ng-invalid
		
When you move among fields:
	- form class is:		ng-pristine ng-invalid ng-touched								ng-untouched >>> ng-touched
	- input class is:		form-control ng-pristine ng-invalid ng-touched					ng-untouched >>> ng-touched
		
When you fill all fields properly:
	- form class is:		ng-touched ng-dirty ng-valid
	- input class is:		form-control ng-touched ng-dirty ng-valid


SEE ALSO:
	https://angular.io/api/forms/NgControlStatus
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Form styling tips for validation	
================================
- To show touched invalid fields specify CSS class:

	input.ng-invalid.ng-touched {
		border: 1px solid red;
	}

- How to display a validation warning?

	<input type="email" class="form-control" ngModel name="email" required #email="ngModel">				<------- local reference to model
	<span class="help-block" *ngIf="!email.valid && email.touched">Please enter a valid email!</span>
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How can you reference a FormControl behind an input field?
==========================================================
Create a local reference to the model behind the field.
For example you want to show a warning if a field is not valid:

	<input type="email" class="form-control" ngModel name="email" required #email="ngModel">				<------- local reference to model
	<span class="help-block" *ngIf="!email.valid && email.touched">Please enter a valid email!</span>

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to group input values in model?	
===================================
You can group input values together in model. 
Use a wrapper div with ngModelGroup="NAME" structure:

	<div ngModelGroup="userData>
		<input name="username" ngModel>
		<input name="email" ngModel>
	</div>
	
Form value will contain:
	NGForm {
		value:	{
					userData: {
						username: '...',
						email: '...'
					}
				}
	
	
Form controls also contains flags for this group:

		controls:	{
						userData: {
							...
						}
					}
					
--------------------------------------------------------------------------------------------------------------------------------------------------
Radio button
============
- Controller has:
	- 'genders' array (male, female) with possible values
	- gender to store result and default value

- Template:

	<div class="radio" *ngFor="let gender of genders">
		<label>
			<input type="radio" name="gender" ngModel [value]="gender">{{gender}}
		</label>
	</div>
	
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
Howto generate FormControls dynamically?
========================================
In model driven method use FormArray:

	this.form = new FormGroup({
		'name': new FormControl(),
		'email': new FormControl(),
		'hobbies': new FormArray([
			'defaultHobby': new FormControl(),
		])
	});

	onAddHobby() {
		const control = new FormControl(null, Validator.required);
		(<FormArray>this.form.get('hobbies')).push(control);
	}
	

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Howto set/patch/reset form values of forms?
===========================================
If you have a local reference to NgForm then:


	@ViewChild('f')signupForm: NgForm;
	
	suggestName() {
	const suggestedName = 'Superuser';
		//this.signupForm.setValue({						// writing the whole form
		//	userData: {
		//		userName: suggestedName,
		//		email: ''
		//	}
		//	secret: 'pet'
		});
		
		this.signupForm.patchValue(							// updating a part of form
		{
			userData: {
				userName: suggestedName
			}
		});
	}

	onSubmit() {
		// save data
		...
		
		// reset after save
		this.signupForm.reset();			// here you can pass an object to reset 
	}


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto display error-specific messages on validation errors?
===========================================================
If a FormControl is invalid then error code is stored into control.errors array.
Error is always a key-value pair, generally a error name and a 'true' value.

For example if a field is validated with 'required' and it's empty you have this value in errors:
	errors: {
		required: true
	}

So you can simply write error message this way:

	<span *ngIf="email.errors['required']">Empty!</span>
	<span *ngIf="email.errors['email']">Bad email format!</span>

	
NOTE:
	In current version it canot work becasue 'errors' property is null if you don't have an error.
	Better way writing a component.
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How service instances propagated?
=================================
You can provide (generate) an instance of a service on any level of application:
- modules
- components

Just put a service into 'providers' array of current element and itt will be instantiated there.

If you provide a service it propagated to the CURRENT component and DOWN to 
it's children (and children of children). The instances are never propagated up, ONLY DOWN.

	UP ----> DOWN

---> If you provide a a service in  the root module all components will use the SAME SINGLE instance of
		this service.
		
---> If you prvide a serice in a child (leaf) component then all components have its own instance of service.



--------------------------------------------------------------------------------------------------------------------------------------------------
Cross-component communication
=============================
Method 1:	You can send events from a componnet to a parent component using @Output + EventEmitter

	DRAWBACK: sometimes you need a chain of property binding 

Method 2:	You can add EventEmitter also to services and somewhere in the application you can subscribe to this EventEmitter.

	Why? 
	Under the hood EventEmitter is an RxJs Subject.
	
	SomeService:
	
		statusUpdated = new EventEmitter<string>();
		
		
	Component:
		constructor(private someService: SomeService) {}
		
		onSomeEvent() {
			this.someService.statusUpdated.emit(newStatus);
		}
	
	Other component:
		constructor(private someService: SomeService) {
			this.someService.statusUpdated.subscribe(
				(status: string) => do_something_with_status
			);
		}
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
Nested routing with Multiple RouterOutlet RouterModule
======================================================
- add routing module to root module
- create child modules with routing

	ng g m RouterTest --routing

	It creates 2 module files:
		- module
		- module routing


- add route to child routing, import RouterModule with forChild:

	const routes: Routes = [
	  { path: '', component: RouterTestMain, children: [
		  { path: 'a', component: AComponent},
		  { path: 'b', component: BComponent},
		  { path: '', redirectTo: 'a', pathMatch: 'full' },
		  { path: '**', component: LazyPage404Component },
		]}
	];
	
	@NgModule({
	  declarations: [],
	  imports: [RouterModule.forChild(routes)],
	  exports: [RouterModule]
	})
	export class RouterLazyRoutingModule { }

		
- add child module routing with lazy loading (loadChildren) to root routing module:

	const routes: Routes = [
		{ path: 'home', component: HomePageComponent },
		...
		{ path: 'router-lazy', loadChildren: () => import('./router-lazy/router-lazy.module').then(m => m.RouterLazyModule) },     // lazy loading
		...
		{ path: '',   redirectTo: '/home', pathMatch: 'full' },   // default
		{ path: '**', component: Page404Component}
	];

	@NgModule({
	  imports: [
		RouterModule.forRoot(routes, { enableTracing: false })    // <-- debugging purposes only
	  ],
	  exports: [RouterModule]
	})
	export class AppRoutingModule { }
	

SEE ALSO:	project: my-ang-demo 

--------------------------------------------------------------------------------------------------------------------------------------------------
Howto use datepicker?
=====================
- import into AppModule:

	import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
	import { BsDatepickerModule } from 'ngx-bootstrap/datepicker';

	@NgModule({
	  imports: [
		BrowserAnimationsModule,
		BsDatepickerModule.forRoot(),
		...
	  ]
	})
	export class AppModule(){}


	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to go back to previous page?
================================
- Using built-in Location service:

	@Component({
	  // component's declarations here
	})
	class SomeComponent {

	  constructor(private location: Location) 
	  {}

	  goBack() {
		this.location.back();
	  }
	}

	<button (click)="goBack()">Back</button>
	OR
	<a href="javascript:void(0)" (click)="goBack()">Back</a>
	
	
- Passing current location to next page:

	Current page:
	
		this.router.navigate(["user/edit"], { queryParams: { returnUrl: this.router.url }
	
	Next page:
	
		onInit() {
			this.router.queryParams.subscribe((params) => {
				this.returnUrl = params.returnUrl;
			});
		}
		
		back() {
			this.router.navigateByUrl(this.returnUrl);
		}
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------
Order of routes
===============
The order of routes is important because the Router uses a FIRST-MATCH WINS STRATEGY when matching routes, 
so more specific routes should be placed above less specific routes. 

	
--------------------------------------------------------------------------------------------------------------------------------------------------
Passing/retrieving parameter with routing
=========================================

Parameters:
	- path
	- query

	Route contains path parameters:
	
		{ path: 'persons/:id/edit', component: PersonDetailComponent},
	
Passing
-------		
- in template:
	- routerLink	: array of fragments
	- queryParams	: map of parameters as a JS object
	- fragment		: after #

	<a [routerLink]="['/hero', hero.id, 'edit']" [queryParams]="{allowEdit: '1'}" fragment="loading">
	
		http://host:port/hero/100/edit?allowEdit=1#loading

- in controller code:
	
	- Router.navigate(commands, extras)

		this.router.navigate(['/hero/', hero.id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});

	- Router.navigateByUrl(url|UrlTree, extras)

		- URL string:
		
			url = '/hero/' + id + '/edit?allowEdit=1#loading';
			this.router.navigateByUrl(url);
		
		- URL tree:
	
			const urlTree = router.createUrlTree(['/hero', id, 'edit']);
			this.router.navigateByUrl(urlTree, {queryParams: {allowEdit: '1'}, fragment: 'loading'});
	
		Tricks:
			UrlTree -> string:		Router.serializeUrl(urlTree)
			string -> UrlTree:		Router.parseUrl(str) 
	
		
Retrieving
----------
constructor(private route: ActivatedRoute) { }

ngOnInit(): void {
	this.id = +this.route.snapshot.params['id'];
	this.extra = this.route.snapshot.fragment;
}


- But this solution is proper ONLY AT THE 1ST TIME. It's not reactive, so after creation there is no chance to detect changes.
If you navigate to the same component Angular won't instantiate it again.
- to listen to parameter changes y ou need an observer. Route.params is an observable:


this.route.params
  .subscribe(
	(params: Params) => {
	  const id = +params['id'];
	}
  );

this.route.fragment
  .subscribe(
	(fragment: string) => {
	  const extra = fragment;
	}
  );
  
IMPORTANT NOTE: 
	You don't have to unsubscribe from this observable - Angular do it automatically when component destroyed.


Example navigations
-------------------
// create /team/33/user/11
router.createUrlTree(['/team', 33, 'user', 11]);

// create /team/33;expand=true/user/11
router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);

// you can collapse static segments like this (this works only with the first passed-in value):
router.createUrlTree(['/team/33/user', userId]);

// If the first segment can contain slashes, and you do not want the router to split it,
// you can do the following:
router.createUrlTree([{segmentPath: '/one/two'}]);

// create /team/33/(user/11//right:chat)
router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);

// remove the right secondary node
router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);

// assuming the current url is `/team/33/user/11` and the route points to `user/11`

// navigate to /team/33/user/11/details
router.createUrlTree(['details'], {relativeTo: route});

// navigate to /team/33/user/22
router.createUrlTree(['../22'], {relativeTo: route});

// navigate to /team/44/user/22
router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});


SEE ALSO:
	https://angular.io/api/router/Router#navigate
	


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto preserve query parameters for the next navigation?
========================================================
constructor(private route: ActivatedRoute) { }

this.router.navigate(['edit'], {relativeTo: route, queryParamHandling: 'preserve'});

- preserve:		same as before
- merge:		same as before + new params


--------------------------------------------------------------------------------------------------------------------------------------------------
Passing data to route
=====================
Static (specifying data in route)
---------------------------------
- add static data to route:

	{ path: 'not-found', component: ErrorPageComponent, data: {message: 'Page not found'}}
	{ path: 'bad-value', component: ErrorPageComponent, data: {message: 'Bad value'}}
	
- retrieve this data in component:

	ngOnInit() {
		this.errorMessage = this.route.snapshot.data['message'];
		this.route.data.subscribe(
			(data: Data) => {
				this.errorMessage = data['message'];
			}
		);
	}
	
	
Dynamic (fetching data during routing)
--------------------------------------
- create a resolver (ServerResolver)
	
	It's a class implementing Resolve<T>.

- add to route:

	{ path: 'edit/%id', component: EditServerComponent, resolve: {server: ServerResolver}}
	
	
- retrieve data in component:

	EditServerComponent:

		constr
	
		ngOnInit() {
			this.route.data.subscribe(
				(data: Data) => {
					this.server = data['server'];
				}
			);
		}

	
How to prevent user from accidentaly navigating away?
-----------------------------------------------------
Use canDeactivate guard.



--------------------------------------------------------------------------------------------------------------------------------------------------
Howto specify default child route?
==================================
Add an empty route into children and redirect to default child route. 

const routes: Routes = [
  { path: 'home', component: HomePageComponent },
  { path: 'broadcast', component: EventBroadcastMain },
  { path: 'rxjs', component: RxjsMain, children: [
      { path: '', redirectTo: 'observables', pathMatch: 'full'},						<<<< redirecting child route
      { path: 'observables', component: ObservablesComponent},
      { path: 'simplelist', component: CourseListComponent},
	  ...
	  
	  
--------------------------------------------------------------------------------------------------------------------------------------------------
@ViewChild vs @ContentChild
===========================
With @ViewChild you can refer an element of the current component template.
With @ContentChild you also refer and elemet on the current component but in the content pushed from the parent into <ng-content>


Child:	
	<div class="alert alert-success" role="alert" #panel>
	  <ng-content></ng-content>
	</div>

  @ViewChild('panel', {static: true}) panel: ElementRef;
  @ContentChild('pushedContentRef', {static: true}) pushedContentRef: ElementRef;

  ngOnInit(): void {
    if (this.pushedContentRef) {
      this.pushedContentRef.nativeElement.style.backgroundColor = 'yellow';     // set background color of referenced pushed content
    }
  }
  

Parent:

	<con-child>injected content <span style="padding: 3px" #pushedContent>PUSHED</span></con-child>
  
--------------------------------------------------------------------------------------------------------------------------------------------------
How to use NgRx in Nx monorepo?
===============================
SEE ALSO: ../Nx/Nx-FAQ.txt/How to use NgRx in Nx monorepo?


--------------------------------------------------------------------------------------------------------------------------------------------------
ERROR: Module not found: Error: Can't resolve 'cache-manager' in '.....\node_modules\@nestjs\common\cache'
==========================================================================================================
Problem:
If you have a monorepo environment with NestJS and Angular project and you accidentally imported a NestJS 
class/module into Angular project.

In this case 'ng build' detects similar problem.


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto initialize reactive form from route resolver?
===================================================
If you want to control data fetching to a form with routing then use a resolver.
It creates an observable for retieving data. This observable need to complete.
We are going to make sure that this observable emits a value and then completes.
The router will only complete the transition to the target screen when observable (returned by resolver) completes.
If this observable does not complete the route transition is going to hang and we will never go to target screen.

- If FormControl names of reactive form are the same as DTO properties then use simple form.patchValue(dto).
- register resolver into routing config:

	{ path: 'config', component: ConfigComponent, resolve: {config: ConfigResolver} },

- Method 1 - without NgRx store:
	
	- Fetch value directly from backend with a Resolver:

		export interface AppConfig {
		  autoChangePresenceStates: boolean;
		}


		@Injectable()
		export class ConfigResolver implements Resolve<AppConfig> {

		  constructor(private configService: ConfigService) {}

		  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<AppConfig> | Promise<AppConfig> | AppConfig {
			return this.configService.getConfig();
		  }
		}

	- then retrieve fetched value in component and call patchValue(val):

		export class ConfigComponent implements OnInit {
		  config: AppConfig;
			
		  constructor(private route: ActivatedRoute, private configService: ConfigService) {
			this.form = new FormGroup({
			  'autoChangePresenceState': new FormControl(false)
			});

			// routing getting resolver data
			this.config = this.route.snapshot.params['config'];
			this.route.data.subscribe(
			  (data: Data) => {
				this.config = data['config'];
				this.form.patchValue(this.config);						<<<<<<< here
			  }
			);

- Method 2 - with NgRx store:

	- create action, e.g. configLoad
	
	- dispatch data from resolver:
	
		@Injectable()
		export class ConfigResolver implements Resolve<AppConfig> {

		  constructor(private store: Store<AppState>) {}

		  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<AppConfig> | Promise<AppConfig> | AppConfig {
			return this.store.pipe(
				tap(() => this store.dispatch(loadConfig())),
				first()											<<<<< emit only 1 value and complete the observable
			);
		  }
		}
	
	
If multiple actions dispathing during router transition (because of devtools) then you can extend this code this way:

		@Injectable()
		export class ConfigResolver implements Resolve<AppConfig> {
		  loading = false;
		  
		  constructor(private store: Store<AppState>) {}

		  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<AppConfig> | Promise<AppConfig> | AppConfig {
			return this.store.pipe(				
				tap(() => {
					if (!this.loading) {
						this.loading = true;
						this store.dispatch(loadConfig());
					}
				}),
				first(),											<<<<< emit only 1 value and complete the observable
				finalize(() => this.loading = false)
			);
		  }
		}
	

	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to save form content without submitting (no save button)?
=============================================================
FormGroup.valueChanges is an observable which emits form value on every changes. Subscribe to it and save changes.
For example:

	export class ConfigComponent implements OnInit {
		form: FormGroup;

		constructor(private route: ActivatedRoute, private configService: ConfigService) {
		this.form.valueChanges.subscribe(value => {
			this.configService.setConfig(value).subscribe()
		})
			
	}


--------------------------------------------------------------------------------------------------------------------------------------------------
Howto avoid multiple subscription with async pipes?
===================================================
Sometimes you need to show the asynchronous data in multiple places of the same component. We don’t want to use async pipe twice because 
it will create two subscriptions instead of one. Multiple subscriptions can be harmful. 
It’s not uncommon that double subscription would lead our frontend to perform two identical http-calls instead of one, 
or dispatch identical actions to your state management engine, or do heavy calculations more than once.

Since Angular 4 the syntax of ngIf and ngFor directives was updated to allow local variables. See ngIf reference for details. 
It's possible to store asynchronous data into a local variable with 'as':


	<div *ngIf="userObservable | async as user; else loading">
		Hello {{user.last}}, {{user.first}}!
    </div>
    <ng-template #loading let-user>Waiting... (user is {{user|json}})</ng-template>


SEE ALSO:
	https://angular.io/api/common/NgIf
	https://medium.com/@yurykatkov/how-to-avoid-multiple-async-pipes-in-angular-ff0d51a8d368
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------
How to dump any (even async) variable from template?
====================================================
You can declare local variables on templates is structural directives.
This variables added to context of template element.

Put an *ngIf into a container element where you need a value to be dumped, like this:

	<div *ngIf="{selectedDirectory: (selectedDirectory$ | async)}; let localVars">
		<button> (click)="dumpVar(localVars)"
	</div>
	
	
  dumpAnyValue(v: any) {
    console.log('DUMP:', v);
  }


NOTE: you can add only a single structural directive to an element.





	
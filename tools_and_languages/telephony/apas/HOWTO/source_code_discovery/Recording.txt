=========
Recording
=========

SEE ALSO:
- Call Recording Examples for Network-Based and Phone-Based Recording
	https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cucm/configExamples/cucm_b_recording-use-cases.html
- RTP payload formats
	https://en.wikipedia.org/wiki/RTP_payload_formats

					
				
				
You need a configured recording environment (see more: APAS-FAQ.txt/Howto configure recorder?)

Source code
-----------
- Constants, parameters


Use-cases
---------
- Initiating a recording
- On-demand recording
- Status page for recording
- Search


Protocol
--------
- Recording protocol between APAS and recorder
- Handling XML messages in recorder 
- XML messages											UNDER CONSTRUCTION

SIP
---
- SIP management
- SIP and JTAPI association (call ID mapping)


Rules
-----
- Registering observers by rules
- Recorder rule matching during registering observers
- RuleSet without rule


Network/Security
----------------
- Packet sniffing
- Handling encryption keys in recorder 

Database
--------
- Writing/changing rec_call table
- Recording start time information


Recording files
---------------
- Structure of REC file
- Post-processing recorded media
- How recordings can be deleted?

Storage profiles
----------------
- KEEP values

C++ Recorder
------------
- What does trigger recording start?								UNDER CONSTRUCTION
- How calls are identified by independent <recordCall> messages?
- Writing recording to file											UNDER CONSTRUCTION
	
Troubleshooting
---------------
- What is 'csip...' call ID?
- ERROR - in APAS event log: The recording of call ... has been locked because a new call has reserved licenses in the ruleset
- dbID=0 on the 2nd recordCall


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Constants, parameters
=====================
- Post processing:

	- Compression/codec:
		COMPRESSION_NONE = 0
		COMPRESSION_ULAW = 1
		COMPRESSION_SPEEX = 2
		COMPRESSION_MASK = 63
		COMPRESSION_UNENCRYPTED = 64

- Rule matchinng:

	- Ruleset: 

		Actions:

			ACTION_NONE=0
			ACTION_RECORD_CALLER=1
			ACTION_RECORD_CALLED=2
			ACTION_RECORD=3
			ACTION_MONITOR_CALLER=4
			ACTION_MONITOR_CALLED=8
			ACTION_MONITOR=12
			ACTION_NEVER=16
			ACTION_CONTINUE=32
			ACTION_KEEP=64
			ACTION_ANNOUNCEMENT=128
			ACTION_DONOTDELETE=256 + ACTION_KEEP = 320
			ACTION_NOTIFICATION=512
			ACTION_ONDEMAND_NOREC=1024
			ACTION_ONDEMAND_REC=2048

		RuleOp:	

			RULEOP_ANY=1			// OR
			RULEOP_ALL=2			// AND
		
	- Rule:

		Source:
			SOURCE_TYPE_CALLER=1
			SOURCE_TYPE_CALLED=2
			SOURCE_TYPE_LASTREDIREDTED=4
			SOURCE_TYPE_ORIGINALCALLER=8
			SOURCE_TYPE_ORIGINALCALLED=16

		Match type:

			MATCH_TYPE_EQUALS=1
			MATCH_TYPE_NOTEQUALS=2
			MATCH_TYPE_REGEX=3
			MATCH_TYPE_NOTREGEX=4

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Initiating a recording
======================
Recording started by sniffer if all required call information collected.
Information comes from 2 sources:
	- JTAPI 
	- SIP
	
- When a new information collected by APAS it sends 'recordCall' XML message to recorder.
- On the first time recorder creates recording entry in the database (rec_call)
	'recordCallResponse' answers contain ID of this record (dbID)
- When all necessary information collected by recorder (callId, terminal, source and destination IP/port) then recorder starts recording and captured packets will
	be saved into file.
	
	
1. JTAPI - general information about call (Cisco Call ID, terminal, calling/called party, ...):

	- com.andtek.andphone.recorder.PhoneCallObserver listens call events

	- PhoneCallObserver is a singleton and associated only phones which has a line with recorder ruleset entry
		- PhoneCallObserver registered in com.andtek.andphone.recorder.Module.initJTAPI(...) as terminal observer
		

	--> com.andtek.andphone.recorder.PhoneCallObserver.terminalChangedEvent(TermEv[] eventList)
		- ON CiscoRTPOutputStartedEv
			--> action = RuleSet.checkRules(call, false).getActionFlags()
			- IF action IS ACTION_RECORD OR ACTION_MONITOR
				- callInfo = new RecordingCallInfo(initiatorTerminal, callID)
				- setting callInfo properties from call (callingParty, calledParty, ...)
				--> sendStartCallToRecorder(...)
					--> isConfiguredSIPTrunkRecording()
						--> xml = callInfo.getXML("sip", "");
						--> LOG(Sending XML to recorder (sip))
						--> recorderClientFactory.getRecorderClient().sendXml(xml)
							--> LOG(XML_SOCKET:sending XML [<recordCall)
				
				XML ===> 
				<recordCall terminal="SEPA45630BB1748" callID="sip19329/1" callingParty="+36110009098" calledParty="+36110009020" callingPartyName="" calledPartyName="" originalCallingParty="+36110009098" originalCalledParty="+36110009020" lastRedirectingParty="" initiated="false"/>
				
				<=== XML
				<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
				
2. SIP - media/stream information (source and destination IP/port):
	
	com.andtek.andphone.sip.trunk.SIPServer
	--> handleEvent(EventQueueWorkerEntry entry)
		--> handleEvents(APASEvent[] events, Object observer)
			--> observer.sipServerEvent(events)
				--> com.andtek.andphone.recorder.RecorderSipTrunk.sipServerEvent(APASEvent[] events)
					--> processAck(...)


				XML ===> 
				2019-12-19 15:53:02,657: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" srcIP="10.51.51.122" srcPort="47793"/>
				2019-12-19 15:53:02,659: 1: worker::send(<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
				2019-12-19 15:53:02,722: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" dstIP="10.51.51.122" dstPort="41899"/>
				2019-12-19 15:53:02,724: 1: worker::send(<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
				


				
This is the XML traffic between APAS and recorder:

	--- start ---
	2019-12-19 15:53:02,421: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" callingParty="+36110009098" calledParty="+36110009020" callingPartyName="" calledPartyName="" originalCallingParty="+36110009098" originalCalledParty="+36110009020" lastRedirectingParty="" initiated="false"/>
	2019-12-19 15:53:02,424: 1: worker::send(<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
	2019-12-19 15:53:02,657: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" srcIP="10.51.51.122" srcPort="47793"/>
	2019-12-19 15:53:02,659: 1: worker::send(<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
	2019-12-19 15:53:02,722: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" dstIP="10.51.51.122" dstPort="41899"/>
	2019-12-19 15:53:02,724: 1: worker::send(<recordCallResponse code="0" string="OK" callID="sip19329/1" dbID="90" state="1"/>
	--- end ---
	2019-12-19 15:53:33,110: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="sip19329/1" stopOut="1" />
	2019-12-19 15:53:33,110: 1: worker::send(<recordCallResponse code="100" string="Call removed"/>
	2019-12-19 15:53:33,170: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="csip25153617" stopOut="1" />
	2019-12-19 15:53:33,170: 1: worker::send(<recordCallResponse code="404" string="Call not found for this terminal and callID"/>
	2019-12-19 15:53:33,170: 1: ->recordCall: <recordCall terminal="SEPA45630BB1748" callID="csip25153617" stopOut="1" />
	2019-12-19 15:53:33,170: 1: worker::send(<recordCallResponse code="404" string="Call not found for this terminal and callID"/>
					
					
SEE ALSO:
	SIP and JTAPI association
	What is 'csip...' call ID?
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
On-demand recording
===================
Participants are:
	- caller
	- called
	- Route Point (RP)

On demand recording can be started with XML service served by recording servlet:

		http://<apas host:port>/andphone/Recorder?page=ondemand&dev=#DEVICENAME# 
		
		--> com.andtek.andphone.recorder.web.RecorderPhoneServicesServlet.doRequest(...)
		---------------------------- if page == PARAM_PAGE_ONDEMAND -------------------------------------------
			--> RecorderPhoneServicesServlet.doOnDemandRequest(..., deviceName, ...)
				- searching live calls which belongs to current device ======> selectedCall				
				--------------------- if call isCurrentlyOnDemandRecording ----------------------
				--> onDemandStopRecord()
					LOG:	<recordCall terminal="rec" callID="sip13293/1" onDemand="0" />
				--------------------- else ----------------------
				--> onDemandStartRecord()				
					LOG:	<recordCall terminal="rec" callID="sip13293/1" onDemand="1" />
		
						
			

		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Recording protocol between APAS and recorder
============================================
Non-secured:
------------
1.	handling CiscoRTPOutputStartedEv on terminal 1

	CiscoRTPOutputStartedEv ===> APAS
	APAS === <recordCall> ===> recorder
	recorder --> DB (insert into rec_call...)
	recorder === <recordCallResponse> ===> APAS

2.	handling CiscoRTPOutputStartedEv on terminal 2

	SAME AS terminal 1
	
3. APAS gets SIP ACK events and sends information about FAREND 

	- APAS gets media information from SIP message
	APAS === <recordCall> ===> recorder (with ip and port)
	recorder --> DB (updating rec_call with new info)
	recorder === <call> ===> APAS
	recorder === <recordCallResponse> ===> APAS
	
4. NEAREND

	same as FAREND 
		
	
[2017-05-03 08:56:56,616] [DEBUG] [ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@5c5820a6)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="sip99720/1" callingParty="9030" calledParty="9000" callingPartyName="" calledPartyName="Cicamica" originalCallingParty="9030" originalCalledParty="9000" lastRedirectingParty="" initiated="false"/>]
[2017-05-03 08:56:57,417] [DEBUG] [APAS-defaultWorker-13] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="sip99720/1" dstIP="192.168.5.245" dstPort="39575"/>]
[2017-05-03 08:56:57,418] [DEBUG] [APAS-defaultWorker-11] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="sip99720/1" srcIP="192.168.5.245" srcPort="39923"/>]
[2017-05-03 08:57:24,487] [DEBUG] [APAS-defaultWorker-15] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="csip31117820" stopOut="1" />]
[2017-05-03 08:57:24,553] [DEBUG] [ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@5c5820a6)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="sip99720/1" stopOut="1" />]
[2017-05-03 08:57:24,557] [DEBUG] [APAS-defaultWorker-17] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEP64A0E714F271" callID="csip31117820" stopOut="1" />]
		
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------	
Handling XML messages in recorder 
=================================	
- Server::callbacks contains function pointers to handlers which registered in main().
- Handler methods are global and reside in record.cpp
- name of methods are the same as XML tag names
- handlers are:
	- getStatus
	- getCalls
	- fetchConfig
	- recordCall
	- monitorCall
	- setPcapCapture
	- setLogConfig

	
--> Worker:run()
		------------------------------------------ semi-infinite loop ---------------------------------------------------
		--> Server::received(...)
			------------------------------------------ loop on callbacks ---------------------------------------------------
				--> callbacks[c].callback(...)
				
	
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Status page for recording						
=========================
XML messages are:
	- getStatus
	- getCalls
	- fetchConfig
	- recordCall
	- monitorCall
	- setPcapCapture
	- setLogConfig

	
recordCall	
----------
- RecordingOnDemandApiServiceImpl:
	REST/recorder/active/{callId}/{extId}?action={action}
		--> com.andtek.andphone.api.rest.controllers.recorder.RecorderController.startOrStopRecordingOnDemand(...)
			- seq = callId/extId																									// re-constructing Cisco Call ID (Daena solution :((((( )
			------------ if action == start ----------------
			--> startRecordingOnDemand(sequence)
				--> com.andtek.andphone.api.services.recorder.impl.RecordingOnDemandApiServiceImpl.startRecordingOnDemand(callId)
					--> com.andtek.andphone.api.services.recorder.impl.startRecordingOnDemand(callId)
						--> call = RecorderRealtimeMonitoringService.getCallStatus(callId)
						-------------------- if call != null ------------------------
						- some announcement-related
						- xml = <recordCall terminal="rec" callID="<CALL_ID>" onDemand="<ON_DEMAND_DONT_RECORD>"			// ON_DEMAND_DONT_RECORD=1		!!!!! NO sip/csip, terminal=rec !!!!!
						--> sendXMLCommand(xml)
							--> [1]
			
			------------ if action == stop ----------------
			--> stopRecordingOnDemand(sequence)
				--> com.andtek.andphone.api.services.recorder.impl.RecordingOnDemandApiServiceImpl.stopRecordingOnDemand(callId)
					--> call = RecorderRealtimeMonitoringService.getCallStatus(callId)
						-------------------- if call != null ------------------------
						--> RecordedCallRepositoryFactory.onDemandStopped(findCallWithCallStatusRecord(call)))
							- xml = <recordCall terminal="rec" callID="<CALL_ID>" onDemand="<ON_DEMAND_OFF>"			// ON_DEMAND_OFF=0		!!!!! NO sip/csip, terminal=rec !!!!!
								--> sendXMLCommand(xml)
									--> [1]
							
	
- PhoneCallObserver:
	--> com.andtek.andphone.recorder.PhoneCallObserver.sendStopRecordingToRecorder(callID, module, terminalName)
			
		xml = <recordCall terminal="<TERMINAL>" callID="<sip+callID>" stopOut="1" />						

	--> com.andtek.andphone.recorder.PhoneCallObserver.sendConferenceCallIDToRecorder(Module, CiscoConferenceStartEv, addXML)

		xml = recordCall terminal="rec" callID="sip+finalCallID>" conference="true" transCallID="<sip"+conferencedCallID> +<addXML> />		!!!!! terminal=rec !!!!!
			
	--> com.andtek.andphone.recorder.PhoneCallObserver.sendTransferredCallIDToRecorder(Module, CiscoTransferStartEv, addXML)
			
		xml = <recordCall terminal="rec" callID="<sip+finalCallID>" transCallID="<sip+transferredCallID>" + <addXML> />			!!!!! terminal=rec !!!!!
			
	--> com.andtek.andphone.recorder.PhoneCallObserver.sendOutputKeyToRecorderIfEncrypted(Module, CiscoRTPOutputKeyEv)		

		xml = <recordCall terminal="<TERMINAL>" callID="<CALL_ID>" keyOut="<KEY>" />

	--> com.andtek.andphone.recorder.PhoneCallObserver.sendInputKeyToRecorderIfEncrypted(Module, CiscoRTPInputKeyEv)

		xml = <recordCall terminal="<TERMINAL>" callID="<CALL_ID>" keyIn="<KEY>" />
		
- RecorderSipTrunk:
	--> com.andtek.andphone.recorder.RecorderSipTrunk.sendStartRecordToRecorder(data, fromNumber, deviceName, callLegId, isFarendRTP, call)
		------------------- if call != null ---------------
			------------------- if isFarendRTP ---------------
				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callID> dstIP="<socket.LocalAddress.HostAddress>" dstPort="<socket.LocalPort>"/>

				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callID> keyIn="<data.EncryptionKeyIn>" />
			--------------------- else -----------------------
				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callID> srcIP="<socket.LocalAddress.HostAddress>" srcPort="<socket.LocalPort>"/>

				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callID> keyOut="<data.EncryptionKeyIn>" />
		------------------- else ---------------
			------------------- if isFarendRTP ---------------
				xml = <recordCall terminal="<TERMINAL>" callID="<csip+callLegId>" calledParty="<fromNumber>" dstIP="<socket.LocalAddress.HostAddress>" dstPort="<socket.LocalPort>"/>
				--------------------- isSrtp -----------------------
					xml = <recordCall terminal="<TERMINAL>" callID="<csip+callLegId>" keyIn="<data.EncryptionKeyIn>" />
			--------------------- else -----------------------
				xml = <recordCall terminal="<TERMINAL>" callID="<csip+callLegId>" calledParty="<fromNumber>" srcIP="<socket.LocalAddress.HostAddress>" srcPort="<socket.LocalPort>"/>
				--------------------- isSrtp -----------------------
					xml = <recordCall terminal="<TERMINAL>" callID="<csip+callLegId>" keyOut="<data.EncryptionKeyIn>" />

	--> com.andtek.andphone.recorder.RecorderSipTrunk.processBye(SIPServer, RequestEvent, ServerTransaction)
		
		xml = <recordCall terminal="<TERMINAL>" callID="<csip+callLegID>" stopOut="1"/>

- RecordingCallInfo:
	
	--> com.andtek.andphone.recorder.RecordingCallInfo.getXML(callIdPrefix, addon)

		xml = <recordCall terminal="<initiator> callID="<callIdPrefix+callId>" <ADDON> callingParty="<CALLINGPARTY>" calledParty="<CALLEDPARTY>" callingPartyName="<CALLINGPARTYNAME>" calledPartyName="<CALLEDPARTYNAME>"
			originalCallingParty="<ORIGINALCALLINGPARTY>" originalCalledParty="<ORIGINALCALLEDPARTY>" lastRedirectingParty="<LASTREDIRECTINGPARTY>" initiated="<TRUE/FALSE>" />
	
- RecorderPhoneServicesServlet:

	--> com.andtek.andphone.recorder.web.RecorderPhoneServicesServlet.onDemandDeleteRecord(callID)
		
		xml = <recordCall terminal="rec" callID="<callID>" onDemand="<ON_DEMAND_RECORD> />			// ON_DEMAND_RECORD=2	!!!!! terminal=rec !!!!!
	
	--> com.andtek.andphone.recorder.web.RecorderPhoneServicesServlet.onDemandStopRecord(call)
	
		xml = <recordCall terminal="rec" callID="<callID>" onDemand="<ON_DEMAND_OFF> />			// ON_DEMAND_OFF=0		!!!!! terminal=rec !!!!!

	--> com.andtek.andphone.recorder.web.RecorderPhoneServicesServlet.onDemandStartRecord(call)
	
		xml = <recordCall terminal="rec" callID="<callID>" onDemand="<ON_DEMAND_DONT_RECORD> />			// ON_DEMAND_DONT_RECORD=1		!!!!! terminal=rec !!!!!
	
	
- RecorderClientImpl (RECORDER-2):
	
	--> com.andtek.andphone.recorder2.impl.RecorderClientImpl.start(RecordingSession)
		--> callId = getShortId()
			
			- callId = terminal.toUpperCase.rigth(4) + typePrefix[0] + callId
		
		xml = <recordCall terminal="<TERMINAL>" callID="<getShortId>															// terminal UPPER-CASE
			+ rtpInfoToXML 
			+ callingParty + 	calledParty + callingPartyName + calledPartyName + originalCallingParty
			+ originalCalledParty + lastRedirectingParty + initiated + onDemand
		/>
	
	--> com.andtek.andphone.recorder2.impl.RecorderClientImpl.stop()
	
		xml = <recordCall terminal="<TERMINAL>" callID="<getShortId> stopIn="1" stopOut="1" 					// terminal UPPER-CASE
			+ rtpInfoToXML
		/>
		
	--> com.andtek.andphone.recorder2.impl.RecorderClientImpl.updateRTP(RecordingSession)
		
		xml = <recordCall terminal="<TERMINAL>" callID="<getShortId> stopIn="1" stopOut="1" 				// terminal UPPER-CASE
			+ rtpInfoToXML
		/>
		
		
- Referer:
	
	--> com.andtek.andphone.sip.Referer.processInvite(...)
	
		xml = <recordCall terminal="<TERMINAL>" callID="<callID>" dstIP="<dstIP>" dstPort="<LocalPort>" />					// maybe dead code
		
		
- SIPTrunk:

	--> com.andtek.andphone.sip.SIPTrunk.processAck(...)
		
		xml = <recordCall terminal="<TERMINAL>" callID="<CALL_ID/Unknown>" dstIP="<sock.LocalAddress.HostAddress>" dstPort="<sock.LocalPort>" />
		
		-------------------- if SIGNALING_SIPTrunk ----------------------
			---------------- if call != null ------------------
				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callId>" dstIP="<sock.LocalAddress.HostAddress>" dstPort="<sock.LocalPort>"/ >
				OR
				xml = <recordCall terminal="<TERMINAL>" callID="<sip+callId>" srcIP="<sock.LocalAddress.HostAddress>" srcPort="<sock.LocalPort>"/ >
			---------------- else  ------------------
				xml = <recordCall terminal="<TERMINAL>" callID="<csip+callId>" calledParty="<fromNumber>" dstIP="<sock.LocalAddress.HostAddress>" dstPort="<sock.LocalPort>"/ >					// !!!!! csip !!!!!!
				OR
				xml = <recordCall terminal="<TERMINAL>" callID="<csip+callId>" calledParty="<fromNumber>" srcIP="<sock.LocalAddress.HostAddress>" srcPort="<sock.LocalPort>"/ >					// !!!!! csip !!!!!!
				
		
	--> com.andtek.andphone.sip.SIPTrunk.processInvite(...)
		<recordCall terminal="<TERMINAL>" callID="<callId>" dstIP="<address>" dstPort="<sock.LocalPort>"/ >					// !!!!!!!! NO sip/csip !!!!!

		
	--> com.andtek.andphone.sip.SIPTrunk.processBye(...)
		
		xml = <recordCall terminal="<TERMINAL>" callID="<sip+callId>" stopOut="1"/ >

	
- SIPTrunkMA:

	--> com.andtek.andphone.sip.SIPTrunkMA.processInvite(...)

		xml = <recordCall terminal="<TERMINAL>" callID="<callID>" dstIP="<dstIP>" dstPort="<LocalPort>" />					// maybe dead code
		
- SoapRecorderAPI:

	--> com.andtek.andphone.soap.SoapRecorderAPI.startStopVoiceRecording(callID, doDelete)
		
		xml = <recordCall terminal="rec" callID="<CALL_ID>"	onDemand="<0/1/2>" />						!!!!! terminal=rec !!!!!

		
[1] com.andtek.andphone.recordermgmt.XMLSocket.sendXml(xml)
	


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Status page for recording						
=========================
Based on Spring MCV.

Configuration:
- web.xml : 
	- servlet:		springRecorder	(DispatcherServlet)
	- pattern:		/recorder/*
	
- springRecorder-servlet.xml : Spring MVC config
	- viewResolver:		org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver
	- templateLoaderPath:	/jsp/recorder
	
- VIEW
	- /jsp/recorder/status.flt
	
- CONTROLLER
	- com.andtek.andphone.recorder.web.StatusCtrl


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Starting call recording
=======================
andphone_record (c++ process) records calls. It start calling if it gets "recordCall" XML commands.
Here are messages between APAS and recorder APAS:

	[ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@6cc178d7)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="sip21172/1" callingParty="+36110009100" calledParty="+36110009020" callingPartyName="" calledPartyName="" originalCallingParty="+36110009100" originalCalledParty="+36110009020" lastRedirectingParty="" initiated="false"/>]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip21172/1" dbID="104" state="1"/>
	[APAS-defaultWorker-11] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="sip21172/1" srcIP="10.51.51.122" srcPort="40895"/>]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip21172/1" dbID="104" state="1"/>
	[APAS-defaultWorker-13] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="sip21172/1" dstIP="10.51.51.122" dstPort="46610"/>]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip21172/1" dbID="104" state="1"/>
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <call callID="sip21172/1" callingParty="+36110009100" calledParty="+36110009020" callingPartyName="" calledPartyName="" origCallingParty="+36110009100" origCalledParty="+36110009020" lastRedirectingParty="" rtpRecorded="0" duplicate="0" keep="0" onDemand="0" record="1" keyIn="000000000000000000000000000000000000000000000000000000000000" keyOut="000000000000000000000000000000000000000000000000000000000000"/>
	[http-nio-8080-exec-10] [XMLSocket.java:426] - XML_SOCKET:sending XML [<getStatus seq="10" />]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <getStatusResponse code="0" string="OK" version="6.2.2-462" mode="sip" srtp="true" signalingProtocols="256"   seq="10"><capture received="3124" dropped="78" tcp="2848" sccp="0" udp="52" rtp="19" rtprec="19" bufmax="2" iomax="0"/></getStatusResponse>
	[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:Got XML message [getStatusResponse: null] with seq=10
	[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:Found SeqWaiter for seq=10
	...
	[ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@6cc178d7)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="sip21172/1" stopOut="1" />]
	[APAS-defaultWorker-15] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="csip25252351" stopOut="1" />]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="100" string="Call removed"/>
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="404" string="Call not found for this terminal and callID"/>
	[APAS-defaultWorker-17] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPA45630BB1748" callID="csip25252351" stopOut="1" />]
		<--[APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="404" string="Call not found for this terminal and callID"/>
	[http-nio-8080-exec-2] [XMLSocket.java:426] - XML_SOCKET:sending XML [<getStatus seq="18" />]


- XML commands are handled by sniffer process with Server object which calls registered handler methods:

		record.cpp main():
		
			server = new Server();
			server->setCallback("getStatus", getXMLStatus);
			server->setCallback("getCalls", getCalls);
			server->setCallback("fetchConfig", fetchConfig);
			server->setCallback("recordCall", recordCall);
			server->setCallback("monitorCall", monitorCall);
			server->setCallback("setPcapCapture", changePcapCapture);
			server->setCallback("setLogConfig", setLogConfig);

- To start recording APAS sends 'recordCall' message(s) to sniffer
- Multiple messages are sent with differennt information about call, RTP stream information (src/dest IP/port), decryption key
			
	<recordCall .../> 
		--> recordCall()
		

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Handling encryption keys in recorder 
====================================
Sample call:

	RECORDING[482][sip13777821/2, CSFFalticko] : 2020-10-06 13:37:35 - 2020-10-06 13:37:51, DB:826586
	RECORDING[1140][sip13777821/2, CSFFalticko] :  - , DB:826586, DiskThread:true 
	   - callingPartyName=Anonymous
	   - srcIP=172.18.97.30
	   - callID=sip13777821/2
	   - calledPartyName=FALTICKO Pavol
	   - stopOut=1
	   - terminal=CSFFalticko
	   - originalCalledParty=+43508115233
	   - srcPort=59807
	   - initiated=false
	   - keyIn=812d8277be43ed034bf6ebea77f8ef4c75760167b3128dbcef2af46d4e90 (gS2Cd75D7QNL9uvqd/jvTHV2AWezEo287yr0bU6Q)
	   - dstIP=172.18.97.30
	   - lastRedirectingParty=
	   - callingParty=Anonymous
	   - originalCallingParty=Anonymous
	   - dstPort=42160
	   - keyOut=7030691a81552d2d51dcfd8671d3f01d1aff9d59b4f2c469d469a5e3358b (cDBpGoFVLS1R3P2GcdPwHRr/nVm08sRp1Gml4zWL)
	   - calledParty=+43508115233 

	[2020-10-06 13:37:35,108] [DEBUG] [ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@21c68aee)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" callingParty="Anonymous" calledParty="+43508115233" callingPartyName="Anonymous" calledPartyName="FALTICKO Pavol" originalCallingParty="Anonymous" originalCalledParty="+43508115233" lastRedirectingParty="" initiated="false"/>]
	[2020-10-06 13:37:35,111] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip13777821/2" dbID="826586" state="1"/>
	[2020-10-06 13:37:35,766] [DEBUG] [APAS-defaultWorker-17] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" srcIP="172.18.97.30" srcPort="59807"/>]
	[2020-10-06 13:37:35,796] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip13777821/2" dbID="826586" state="1"/>
	[2020-10-06 13:37:35,797] [DEBUG] [APAS-defaultWorker-17] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" keyOut="7030691a81552d2d51dcfd8671d3f01d1aff9d59b4f2c469d469a5e3358b" />]
	[2020-10-06 13:37:35,798] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip13777821/2" dbID="826586" state="1"/>
	[2020-10-06 13:37:35,978] [DEBUG] [APAS-defaultWorker-25] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" dstIP="172.18.97.30" dstPort="42160"/>]
	[2020-10-06 13:37:35,978] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip13777821/2" dbID="826586" state="1"/>
	[2020-10-06 13:37:35,978] [DEBUG] [APAS-defaultWorker-25] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" keyIn="812d8277be43ed034bf6ebea77f8ef4c75760167b3128dbcef2af46d4e90" />]
	[2020-10-06 13:37:35,983] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip13777821/2" dbID="826586" state="1"/>
	[2020-10-06 13:37:51,934] [DEBUG] [ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@21c68aee)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFFalticko" callID="sip13777821/2" stopOut="1" />]   
	   

- How to get keys from SIP conversation?

	Nearend:

		CUCM				  APAS
		  |------ INVITE ------>|
		  |<---- Trying --------|
		  |<------ OK ----------|
					m=audio 59807 RTP/SAVP 0 8 9 18 101																		// local port to receive RTP from nearend device
					a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:GpdRQofAGOXkvQQv+rNfL22n3P6ai4iToYpMffor 						// APAS sends local hardcoded key to CUCM - never used (since we don't send RTP to CUCM)
		  |------- ACK -------->|
					m=audio 23386 RTP/SAVP 8 101																			// endpoint of RTP stream on CUCM (not used by recording, only APAS port used for packet identification)
					a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:cDBpGoFVLS1R3P2GcdPwHRr/nVm08sRp1Gml4zWL 						// key which used by recorded (nearend) device when RTP sent to other endpoint (keyOut)
		  |-------- BYE ------->|
		  |<-------- OK --------|
		  
	Farend:
	
		CUCM				  APAS
		  |------ INVITE ------>|
		  |<---- Trying --------|
		  |<------ OK ----------|
					m=audio 42160 RTP/SAVP 0 8 9 18 101																		// local port to receive RTP from nearend device
					a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:GpdRQofAGOXkvQQv+rNfL22n3P6ai4iToYpMffor 						// APAS sends local hardcoded key to CUCM - never used (since we don't send RTP to CUCM)
		  |------- ACK -------->|
					m=audio 17868 RTP/SAVP 8 101																			// endpoint of RTP stream on CUCM (not used by recording, only APAS port used for packet identification)
					a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:gS2Cd75D7QNL9uvqd/jvTHV2AWezEo287yr0bU6Q						// key which used by not-recorded (farend) device when RTP sent nearend (keyIn)
		  |-------- BYE ------->|
		  |<-------- OK --------|




How to create/get SRTP keys?
	- SRTP out key is ALWAYS the same HARDCODED value:	RecorderSipTrunk.SRTP_OUT_KEY
	- SRTP in key retrieved from SIP ACK SDP message:
	
		[2018-04-23 13:15:20,269] [>RECEIVED] [SIPServer-6] [ACK sip:APAS@192.168.150.142:5061;transport=tls]
		ACK sip:APAS@192.168.150.142:5061;transport=tls SIP/2.0
		...
		a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:YeMbPF3M4z1/kANIEZGtXJ1e++W0uTgFws2zhKoo
		...
		
During a secure call (when both of terminals has a Secure Device Profile) phones send payload in SRTP.
To encrypt data terminals have security key-pairs.

	Terminal A incoming key --------------- Terminal B outgoing key
	Terminal A outgoing key --------------- Terminal B incoming key

	
To get encryption information there are 4 (!!!!) ways in APAS:
	
1. Getting info from SIP protocol
---------------------------------	
SIP ships keys in SDP layer. You can trace SIP data in sip_protocol.log:

	...
	m=audio 40953 RTP/SAVP 0 8 9 18 101
	a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:GpdRQofAGOXkvQQv+rNfL22n3P6ai4iToYpMffor
	...
	
	Call flow of ACK handler to get keys:
	
	com.andtek.andphone.sip.trunk.SIPServer
	--> handleEvent(EventQueueWorkerEntry entry)
		--> handleEvents(APASEvent[] events, Object observer)
			--> observer.sipServerEvent(events)
				--> com.andtek.andphone.recorder.RecorderSipTrunk.sipServerEvent(APASEvent[] events)
					--> processAck(...)
						--> key = cryptoPart.substring("inline:".length());
						
							Keys are in base64 encoded format in SDP and will be written into RecorderSipTrunkApplicationData (data).
						
						--> data.setEncryptionKeyIn(StringUtils.toHexString(Base64.decode(key), ""));							<<<<<< keys are encoded with Base64 in SIP protocol
							data.setSrtp(true);

						--> sendStartRecordToRecorder(data, fromNumber, deviceName, callID, dir, call)
							
							--> if (data.isSrtp())
									getRecorderClient().sendXml(...);

									XML will be sent to C++ recorder process with key information (in HEX coded format):
									
										<recordCall terminal="SEPEC44761F83FC" callID="sip9615/1" keyIn="95a42db42c584355fed07e8dab770d424bd04ac0c53221796fd816a8a6d1" />

									and logged into andphone.log - too:
									
										[2015-06-12 09:40:03,389] [DEBUG] [APAS-defaultWorker-13] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="SEPEC44761F83FC" callID="sip9615/1" keyOut="5d5c1cb51ee663b7f2b4cd3cb4f6898be630784bc190f256d3ef21ec65ae" />]

									
								======> andphone_recorder (C++)
								
									--> record.cpp - recordCall(...)
										- getting direction (dir) comes from attribute name: keyIn/keyOut
										- allocating SRTP session record if does not exits (srtp_session[dir])
										--> update_srtp_keys(call, attr, dir)
											- it decodes HEXA encoded key into bytes
											- keys written into call->srtp_key[dir]
											- keys also referred by call->srtp_policy[dir].key
											
											Log written into recorder log:
											
											....
											

2. Via JTAPI event
------------------
	Encryption status can be retrieved when an observer gets CiscoRTPInputKeyEv or CiscoRTPOutputKeyEv events:

		ev.getCiscoMediaSecurityIndicator()

	Keys can be retrieved with:

		ev.getCiscoMediaEncryptionKeyInfo().getKey()
		

CiscoRTPInputKeyEv ==> PhoneCallObserver.terminalChangedEvent()
	--> sendInputKeyToRecorderIfEncrypted(...)
	
CiscoRTPOutputKeyEv ==> PhoneCallObserver.terminalChangedEvent()
	--> sendOutputKeyToRecorderIfEncrypted(...)
		

3. .....

		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Packet sniffing
===============
By default there is no PCAP filter so ALL PACKETS will be captured by sniffer.
- main() contains PCAP loop which calls back packet processor method (my_callback) where
	- it identifies ethernet and 802.1q VLAN frames
	- it recognises UDP packets
	- and calls handle_udp()


	main()
		--> while(getopt(...))

		LOG:
			2017-May-03 08:46:47.614: 0: =======================================
			2017-May-03 08:46:47.614: 0: andphone_record V5.7.4-403 started

		--> db->connect()
		-->pcap_loop(descr[0],  0, my_callback, args
		---------------------------- loop while terminating -------------------------
		--> my_callback(...)
			- it processes sniffed packets
				- identifies ethernet and 802.1q VLAN frames
				- recognises UDP packets and...
			--> handle_udp(...)
				- LOG(|source:)
					
					2017-May-03 08:56:58.134: 3: |source: 192.168.5.206 len: 200 port source: 26258  dest: 39575 seq: 4850 ts: 4172826538 flags: 0880
				
				- ignoring RTP with DTMF tone
				- finding call for packet
				
				
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Post-processing recorded media			
==============================

- Call frow:
			
	--> com.andtek.andphone.recorder.background.BackgroundThrd.run()
		-------------------------- in every 10 seconds -------------------------------
		--> com.andtek.andphone.recorder.Admin.recorderBackgroundProcessing()
			--> Admin.recorderBackgroundProcessing(false)
				--------------- ONLY in maintenance hour ----------------------
					--> Admin.maintenance();
						- archiveSize = collecting recorded file size from filesystem ((from recording directory with 'du') and writing into config
						- calculating deletesize (size to be deteted by maintanance)
							deletesize = archiveSize - KB * config(recorder,DeleteThreshold)
						- SELECT all recordings except which cannot be deleted ORDER BY end
							------------------------- loop on recordings while deletesize > 0 --------------------------
							- delete recording file from filesystem
							- update recording status in DB to Recording.STATE_BACKEDUP
							- deletesize -= size of deleted file
							
							LOG:	Deleted recording.*of size.*KB
						
						--> [1] storageProfileMaintenance(time=0) 
						
				--------------- always ----------------------
					--> Admin.postProcessRecording(recmod, connForRead)
						recPassword = Config(recorder, EncPassword) if specified
					
						- updating status to COMPLETE after 300 seconds? Why?
							UPDATE rec_call SET status=STATE_RECORDING_COMPLETE,lastaction=NOW(), rec_password=PWD 
							WHERE status<=STATE_RECORDING AND (UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(lastaction)) > 300				
						
						--------------------------------- loop on all COMPLETED recording from database --------------------------------------
							- rec = Recording from RecordSet
							- recId = ID of recording 
							
									LOG:	PRocessing recording[recId]						// TYPO fixed to 'Processing recording ...' in 6.2.2
							
							- ID=ID from rec_call
							- try to update record status to PROCESSING:
								UPDATE rec_call SET rec_password=PWD, status=STATE_PROCESSING,lastaction=NOW() 
								WHERE status=STATE_RECORDING_COMPLETE AND id=ID								
							- if no record updated then get next recording (for...continue)
							
							--> updateStorageProfileOnRecord(recId)
								- Update the storage profile of the recording by reading calling/called/lrp information and comparing to the configured rules								
									UPDATE rec_call SET keep=?,lastaction=NOW() WHERE id=?

							- error handling of profile setting
							
								LOG:		'Failed to update storage profile on recording record with id' + recId
								or
								LOG:		'Storage profile 0, not updating header'
								else
								LOG:		'Storage profile ' + profile ID + ', updating header'
							
							- setting calling/called party name from lookup
							- setting compression from Config(recorder,Compression)		// generally 2 (COMPRESSION_SPEEX)
							
							--> com.andtek.andphone.recorder.Recording.writeFile()
								
									LOG:	'Converting file ' + recId
									
								---------------- if file does not exist ---------------------

								- merging WAV file:
								
									LOG:	'merging recordings to stereo wav file: ' + command with filenames
									
										/usr/bin/mergewav /var/lib/andphone_record/plugins /var/lib/andphone/tmp/4_in.wav /var/lib/andphone/tmp/4_out.wav /var/lib/andphone/tmp/4.wav
									
									--> SCRIPT: mergewav
									
								- speex conversion:
									
									LOG:	'encoding recording to speex file:' + command
									
										encoding recording to speex file: /usr/bin/speexenc -n --quality 8 --comp 3 --nframes 1 --comment type=ANDPhoneRecording /var/lib/andphone/tmp/1636361.wav /var/lib/andphone/archive/2020/05/07/05074722522240_1636361.spx
								
									--> SCRIPT:	speexenc
									
								- checking size of result file:
									------------------------- if size < 1024 ------------------------
										- LOG:	'deleting temporary wavfile ' + filepath + ' because it is to small: ' + size							// !!!!!! TYPO foxrd in 6.2.2 to  'too small'
										
											deleting temporary wavfile /var/lib/andphone/archive/2020/05/07/05074722522240_1636361.spx because it is to small: 263
											
										- encfile = null					// for further steps
										
							----------------------- if NOT written -----------------------------------
								- LOG:	'Deleting recording ' + recId + ' from DB because writeFile returned false'
								- DB:	DELETE FROM rec_call WHERE id=" + recId
							----------------------- if written -----------------------------------
								- updating recording info into DB:
								
									UPDATE rec_call SET status=?,lastaction=NOW(),codec=?,filesize=?,callingpartyname=?,calledpartyname=?,filename=? WHERE id=?
								-------------- if keep == 3 ----------------
									--> AdminHelper.encryptLockedRecording(rec)
								--> recEventManager.sendRecorderEvent(...)
									
					--> Admin.storageProfileMaintenance(limited to profiles shorter than 1 day)
					--> Recording.numberOfUsedLicenseToday()
									
								
[1] --> Admin.storageProfileMaintenance()
		-------------------------- loop on storage profiles ----------------------------------
		--> AdminHelper.dbSelectExpiredRecordingsByProfile(which not Recording.STATE_DONOTDELETE) max 5000 items
			- delete recording file
			- update recording status in DB to Recording.STATE_BACKEDUP
			
				LOG:	Deleted recording.*of size.*KB
			------ if delete was not successful (file does not exist) ------
				--> AdminHelper.dbDeleteRecording(id);

			--------------- if profile doen not keep metadata ----------
				--> AdminHelper.dbDeleteRecordingByStatusAndProfile(Recording.STATE_BACKEDUP, profileId)
					DELETE FROM rec_call WHERE ....


						

- Log written into:		andphone-bg.log				

------------------------------------------------------------------------------------------------------------------------------------------------------------------
SIP management			
==============
- SipServer is a GenericServer which implements SipListener
- it listening and waiting for SIP messages via SIP trunk
- it sends 1 OK as response for 1 INVITE


APAS - CUCM
< INVITE
> TRY
< OK


Event handling infrastructure:
------------------------------

SipServer


INVITE:
-------
==> SIP INVITE
	--> SipServer.processRequest(RequestEvent requestEvent) 					// waiting for SIP messages
		SIP-PROTOCOL-LOG:
		
			[2018-03-16 14:22:58,893] [>RECEIVED] [SIPServer-3] [INVITE sip:897999999@10.89.63.20:5060]
			INVITE sip:897999999@10.89.63.20:5060 SIP/2.0

		LOG:
			
			... [EventScannerThread] [SIPServer.java:218] - Request INVITE received at SIPServer-3 with server transaction id null
			
		on Request.INVITE
		--> processInvite(...)
			LOG: 
			
				... [EventScannerThread] [SIPServer.java:702] - SIPServer[APAS](agent(10.89.63.20:5060, udp) ---> server[3](Sub_DCN, 10.89.62.16:5060) available:true - REQUEST: Invite
				... [EventScannerThread] [SIPServer.java:717] - SIPServer[APAS](agent(10.89.63.20:5060, udp) ---> server[3](Sub_DCN, 10.89.62.16:5060) available:true: toUri=sip:897999999@10.89.63.20
				... [EventScannerThread] [SIPServer.java:721] - SIPServer[APAS](agent(10.89.63.20:5060, udp) ---> server[3](Sub_DCN, 10.89.62.16:5060) available:true: number=897999999, fromNumber=+4920151793501
				... [EventScannerThread] [SIPServer.java:728] - SIPServer[APAS](agent(10.89.63.20:5060, udp) ---> server[3](Sub_DCN, 10.89.62.16:5060) available:true: Sending Trying
				... [APAS-defaultWorker-28] [RecorderSipTrunk.java:83] - com.andtek.andphone.recorder.RecorderSipTrunk@26ed4021: Invite received

			
			--> sendSipResponse(serverTransaction, response)		==> SIP Trying
				SIP-PROTOCOL-LOG:
				
				[2018-03-16 14:22:58,895] [SENT>] [SIPServer-3] [100 Trying]
				SIP/2.0 100 Trying

			
			--> sendEvent(new SipInviteReceivedEvent(this, requestEvent, serverTransaction)		================ internal event to APAS =======>
			--> handleEvents(APASEvent[] events, Object observer) 
				--> 				SIPServerObserver ob = (SIPServerObserver)observer;
									ob.sipServerEvent((APASEvent[]) events);
			
			=> SipInviteReceivedEvent
			
			--> RecorderSipTrunk.sipServerEvent()
				--> processInvite(SIPServer server, RequestEvent requestEvent, ServerTransaction serverTransaction)
					--> sendInviteOK(ServerTransaction serverTransaction, Response okResponse)
						LOG:	Dialog state before 200:
						--> sendSipResponse(serverTransaction, okResponse)
							--> SipProtocolLog.log(response, getSipStackName())
							--> serverTransaction.sendResponse(response)
						LOG: Dialog state after 200


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Writing/changing rec_call table
===============================
- GdprService			

	...
	--> GdprService.deleteRecordingEntry();				DELETE

	
- RecorderApiService 

	--> RecorderController.updateRecording()
		-->RecorderApiService.updateRecording()
			--> RecorderApiService.saveRecording()		UPDATE *
					

	--> RecorderApiService.deleteRecording(int recid)		DELETE
	
		
		
- com.andtek.andphone.recorder.Admin

		
	--> Admin.processAction(ConnectionBean connection)		DELETE
		
		
	--> Admin.recorderBackgroundProcessing()			
		--> maintenance									DELETE, UPDATE status, lastaction
		
	
	--> Admin.postProcessRecording(Module recmod, Connection connForRead) 			UPDATE status, lastaction, rec_password
																					UPDATE rec_password, status, lastaction
																					DELETE
																					UPDATE status, lastaction, codec, filesize, callingpartyname, calledpartyname, filename
																					UPDATE status, lastaction, codec, filesize
	
	--> Admin.updateStorageProfileOnRecord()		UPDATE keep, lastaction
	
	--> Admin.createTestRecording.createTestRecording(int count)		INSERT
																					
- AdminHelper
	
	--> dbDeleteRecording(int recID)		DELETE
	
	--> dbDeleteRecordingByStatusAndKeep(int status,int profileId)			DELETE
	
	--> dbUpdateRecordingStatus( int recID, int status)			UPDATE status, lastaction
	
- com.andtek.andphone.recorder.gwtapp.server.RPCrecorderServiceImpl

	--> RemoteDeleteRecordingFiles 		DELETE
	
	--> RemoteGetArchivesList(...)		UPDATE filesize
		
	--> RemoteSetAdminNote(...)			UPDATE admin, lastaction
										
	--> RemoteSetStorageType(...)		
		

- RECORDER calls.cpp:

	--> call_insert_db(...)		INSERT
	
		sql << "INSERT INTO rec_call (start," << db->mapColumn("end")
		<<	",lastaction,status,initiated,signaling,keep,duplicate,"
		<< "callingparty,calledparty,callingpartyname,calledpartyname,origcallingparty,origcalledparty,gcid) "
		<< "VALUES (NOW(),NOW(),NOW(),"
		<< call->status << ",1," << call->type << "," << call->keep << "," << call->duplicate
		<< ",?,?,?,?,?,?,?)"; 
		
	--> call_keep(u_int32_t phoneIP)		UPDATE end, lastaction, keep, duplicate
	
	--> call_update_lastaction_db(...)		UPDATE end, lastaction
	
	--> call_update_keep_db(...)		UPDATE keep
	
	--> call_update_start_db(struct call * call)		UPDATE start, end, lastaction
	
	--> call_update_db(struct call * call, int requirelock)			UPDATE (see SQL below)
	
			sql_cmd << "UPDATE rec_call SET " << db->mapColumn("end") << "=NOW(),lastaction=NOW(),"
			<< "phoneip=\'" << addr_buf << "\'"
			<< ",remoteip=\'" << inet_ntoa(remoteIpAddress) << "\'"
			<< ",status=" << call->status
			<< ",initiated=" << call->initiated
			<< ",initiator=\'" << call->initiator << "\'"
			<< ",filename=\'" << call->filename << "\'"
			<< ",filesize=" << call->filesize
			<< ",signaling=" << call->type
			<< ",codec=" << call->codec
			<< ",duplicate=" << call->duplicate
			<< ",callingparty=?, calledparty=?, callingpartyname=?, calledpartyname=?"
			<< ",origcallingparty=?, origcalledparty=?, gcid=? "
			<< "WHERE id=" << call->id; 
			
			'start' NOT updated here.
			
			
			
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Recording start time information
================================
Start time of recording	- stored into [rec_call/start] database field.

INSERTED:
	calls.cpp:

		--> call_insert_db(...)		
		
			sql << "INSERT INTO rec_call (start," << db->mapColumn("end")
			<<	",lastaction,status,initiated,signaling,keep,duplicate,"
			<< "callingparty,calledparty,callingpartyname,calledpartyname,origcallingparty,origcalledparty,gcid) "
			<< "VALUES (NOW(),NOW(),NOW(),"
			<< call->status << ",1," << call->type << "," << call->keep << "," << call->duplicate
			<< ",?,?,?,?,?,?,?)"; 


	Initial value of 'start' will be NOW() in CPP recorder. That means when recorder staring recording (not the start of call).
	
UPDATED:
	calls.cpp
		--> call_set_onDemand(...)
			------------- if(call->ondemand == 1) ---------------
			--> call_update_start_db(struct call * call)		UPDATE start, end, lastaction
	
			        sprintf(sqlbuff,"UPDATE rec_call SET start=NOW(),%s=NOW(),lastaction=NOW() WHERE id=%d", db->mapColumn("end").c_str(), call->id); 
					
		If this method called (when an on-demand event received) 'start' updated with the current time.
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
KEEP values
===========
keep < 10	: built-in values

	0	: delete recording emmediately 
	
	1	: ?
	
	2	: ?
	
	3	: recording blocked
	
		If active call's in recorder > config(recorder/MaxCalls) recording will be blocked.
		That means it won't be accessible later (GWT comment: if it is a locked recording, don't show download or playback)
		and this recording will be encrypted during post processing:
		
			com.andtek.andphone.recorder.background.BackgroundThrd.run()
				--> com.andtek.andphone.recorder.Admin.recorderBackgroundProcessing()
					--> postProcessRecording(Module recmod, Connection connForRead)
						--> AdminHelper.encryptLockedRecording(rec);
		
						Runtime.getRuntime().exec("openssl enc -aes-128-cbc -salt -in " + rec.getAbsolutePath()+".tmp" + " -out " + rec.getAbsolutePath() + " -k soascheenadog");

			So file encrypted with aes-128-cbc and password is: 	soascheenadog
	
keep >= 10	: ID of storage profile 


- inserted by recorder with 0
- updated by APAS in Admin.updateStorageProfileOnRecord() by background processing:

	In every 10 seconds	

	--> com.andtek.andphone.recorder.background.BackgroundThrd.run()
		--> com.andtek.andphone.recorder.Admin.recorderBackgroundProcessing()
			--> recorderBackgroundProcessing(false)
				--> postProcessRecording(...)
					--> updateStorageProfileOnRecord(int id)
		
						------ if keep < 1 -----------
						- keepAction = RuleSet.checkAllRules(...)
						- update rec_call:
						
							UPDATE rec_call SET keep=?,lastaction=NOW() WHERE id=?


------------------------------------------------------------------------------------------------------------------------------------------------------------------
ERROR - in APAS event log: The recording of call ... has been locked because a new call has reserved licenses in the ruleset
============================================================================================================================
This event generated by recording process and pushed to APAS via XML and it displayes this message as event.


call.cpp

.... UNDER COSTRUCTION


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Search
======
APAS/Recorder/Search

GWT page
--------
-->com.andtek.andphone.recorder.gwtapp.client.search_gwtappMain
	--> initGWTPanels()
		--> buildSearchPanel()
			
			
com.andtek.andphone.recorder.gwtapp.client.search_gwtappMain  (Search button) ===> 
	--> RemoteSearchRecordingFiles(...)
		RCP --> com.andtek.andphone.recorder.gwtapp.server.RPCrecorderServiceImpl.RemoteSearchRecordingFiles(...)
				--> wherer = buildCompleteRecordingWhereClause(userattrs)
					--> SELECT FROM rec_call ...
					
		onSuccess --> buildSearchDynamicListGrid(datarows, ...)

		LIST RENDERED:
			com.andtek.andphone.recorder.gwtapp.client.RecordingListPanel
			


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Registering observers by rules
==============================
Getting rulesets with rules from the database:

	select *
	from rec_rulesets rs, rec_rules r
	where rs.id = r.rulesetid


SEE ALSO: Constants, parameters

Callflow
--------
- com.andtek.andphone.recorder.PhoneCallObserver listens call events

- PhoneCallObserver is a singleton and associated only phones which has a line wich matches with recorder rule entry

- PhoneCallObserver registered as terminal observer [4a/b]:
	- during startup in com.andtek.andphone.recorder.Module.initJTAPI(...) [1]
		OR
	- during adding a ruleset in Admin UI [2]

- Rule configuration stored into DB:
	
	rec_rulesets --1-------------------*-- rec_rules
	

- Observer registration scenarios:	
	- [1] APAS start
	- [2] Adding rule in AdminUI rule page:
	- [3] Adding terminal to application user
	- [4] Device logged in with EM 
	
	
	[1] --> com.andtek.andphone.JTAPIThread.run()
			--> initJtapi(...)
				--> doInitJtapi(primaryCapf)
					--> com.andtek.andphone.utils.Modules.initJTAPI(this)
						--> initJTAPI(...)
							--> com.andtek.andphone.recorder.Module.initJTAPI(...)
								--> RecordedTerminalsRepositoryImpl.observeTerminals(...)
									--> RecordedTerminalsRepositoryImpl.observeRecordedTerminals(...)
										--> [10] recordedTerminalsRepository.observeTerminals(allTerminals, [9a], [9b])
	
	[2] APAS/Recorder/Rules/<add/choose>
	--> rules_gwtappMain
		--> onFormPanelSubmitEvent(formPanel, true)
			--> RemoteSaveRecorderRule(APAS_MODULE, record, func, closeWindow)			
				RPC --> com.andtek.andphone.recordermgmt.gwtapp.server.RPCrecorderServiceImpl.RemoteSaveRecorderRule()
					--> checkEnvironment(...)
					--> RulesAdminHelper.internalSaveRule(...)							
						- It saves/update ruleset/run entries in DB
					--> RulesAdminHelper.sendHUPToSniffer(warningMessage, jtapi)
						--> com.andtek.andphone.recorder.Module.monitorLines(jtapi)
							--> [10] recordedTerminalsRepository.observeTerminals(allTerminals, [9a], [9b])
			
	[3] Adding terminal to application user 
		-->	com.andtek.andphone.CiscoJtapiProviderObserver()
			--> com.andtek.andphone.utils.Modules.providerEvent(jtapi, eventList[i])
				--> com.andtek.andphone.recorder.Module.providerEvent(ProvEv provEv)
					--> com.andtek.andphone.recorder.repositories.impl.RecordedTerminalsRepositoryImpl.observeTerminalOnAddressIfNecessary(address, [9a], [9b])
						--> void observeTerminal(...)

	[4] Device logged in with EM 					
			SAME AS [3]
			
	[9a] --> com.andtek.andphone.recorder2.RecorderCallObserverFactory.createOrGetTerminalObserver()
			--> PhoneCallObserver.getObserver()												<<<<<<<<<<<<<<<<<<<<<<<<< it creates singleton RecorderCallObserver on-demand

	[9b] --> com.andtek.andphone.recorder2.RecorderCallObserverFactory.createOrGetCallObserver()
			--> PhoneCallObserver.getObserver()												<<<<<<<<<<<<<<<<<<<<<<<<< it creates singleton RecorderCallObserver on-demand
						
						
	[10] --> com.andtek.andphone.recorder.repositories.impl.RecordedTerminalsRepositoryImpl.observeTerminals(allTerminals, terminalObserver,  callObserver)
			- registering observers for terminals matching with recorder rules
			--> observeRecordedTerminals(allTerminals)
				--> RuleSet.loadRules()
				-------------------------- loop on terminals ------------------------------
					-------------------------- loop on addresses of a terminal ------------------------------
						--> RecordedTerminalsRepositoryImpl.observeAddressOnTerminalIfNecessary(terminal, address))			<<<<<<<<<<<< register observer if rule matches
							--> matches = if ruleMatchesAddressForObserverRegistration() 
								--> RuleSet.checkRules(address, CALLER | CALLED | LASTREDIREDTED | ORIGINALCALLER | ORIGINALCALLED, checkArchive = false, forceMatchAny = true)
									- internally it calculates an action and returns true if action > RuleAction.ACTION_NONE
									--> action = checkAllRules(MatchRecord, checkArchive = false, forceMatchAny = true)
										------------------------------- loop on rulesets --------------------------------------
										--> match = ruleSet.matches(rec, forceMatchAny)
								
								
								
								
							---------------------- if matches -----------------------------
								--> observeTerminal(terminal)
								- if registerd then break from addresses loop



------------------------------------------------------------------------------------------------------------------------------------------------------------------
Recorder rule matching during registering observers
===================================================
- PhoneCallObserver is a singleton and associated only phones which has a line wich matches with recorder rule entry
- RuleSet initiated with all rules from DB
- At startup all addresses of all terminals (assigned to application user) participated as 
	- calling party
	- called party
	- original calling party
	- original called party
	- last redirected party

		--> RecordedTerminalsRepositoryImpl.observeAddressOnTerminalIfNecessary(terminal, address))			<<<<<<<<<<<< register observer if rule matches
			--> matches = ruleMatchesAddress()
				--> RuleSet.checkRules(address, CALLER | CALLED | LASTREDIREDTED | ORIGINALCALLER | ORIGINALCALLED, checkArchive = false, forceMatchAny = true)
					--> action = checkAllRules(MatchRecord, checkArchive = false, forceMatchAny = true
						- it accumulates actions from matcing rulesets
						- if any ruleset provides ACTION_NEVER (deny/block) then result action will be ACTION_NONE
						------------------------------- loop on rulesets --------------------------------------
							--> match = ruleSet.matches(rec, forceMatchAny)
							IF match																			// only log
								BUT actions == ACTION_CONTINUE (only continue has been set but no other)
									--> LOG: *MATCH_BUT_DID_YOU_FORGET_TO_SPECIFY_ACTIONS*
								ELSE
									--> LOG: *MATCH*
							IF match																			// business logic
								- accumulate action from current ruleset
								IF accumulated_actions NOT CONTAINS ACTION_NEVER | ACTION_KEEP
									--> continue
								IF accumulated_actions NOT CONTAINS ACTION_CONTINUE
									--> break from loop															// evaluation stopped on rule match
							
									
							matches = found action (boolean)
							---------------------- if matches -----------------------------
								--> observeTerminal(terminal)


- During registering observers rules are always used in OR (any match) logical operation ('Match if' value of ruleset ignored)

- During processing all rulesets enumerated until a matching ruleset found where 'continue rulecheck on match' not specified
	That means: if a ruleset is NOT matching the next ruleset ALWAYS processed.
	
- Actions are accumulated from enumerated matching rulesets (added to action flags with binary OR)

- If the result action flags contain BLOCK (RuleAction.ACTION_NEVER) then actions will be deleted (will be set to RuleAction.ACTION_NONE)

- If result action flags contain ANY action then observer will be registered to terminal 				
				
- Observers ara NEVER removed, even if you delete matching rules. These (orphan) observers can be deleted only with SOFT RESTART.

				
------------------------------------------------------------------------------------------------------------------------------------------------------------------
RuleSet without rule
====================
A ruleset is matching if evaluation of ruleset provides an action. That means:
- if you have a ruleset without rules and this ruleset is at the final position IT DOES NOT HAVE ANT AFFECT
- if you have a ruleset without rules and this ruleset is NOT at the final position the ALL NEXT RULESETS ARE SKIPPED 


------------------------------------------------------------------------------------------------------------------------------------------------------------------
SIP and JTAPI association (call ID mapping)
===========================================
SIP information extracted on ACK signal:


	[2020-02-28 07:47:10,064] [DEBUG] [APAS-defaultWorker-13] [RecorderSipTrunk.java:248] - From=sip:+36110009020@10.51.51.34;x-farend;x-refci=25252351;x-nearendclusterid=StandAloneCluster;x-nearenddevice=SEPA45630BB1748;x-nearendaddr=+36110009020;x-farendrefci=25252350;x-farendclusterid=StandAloneCluster;x-farenddevice=SEP100000009100;x-farendaddr=+36110009100

	
	Fields in ACK:
		- From=sip:+36110009020@10.51.51.34;
		- x-farend
		- x-refci=25252351
		- x-nearendclusterid=StandAloneCluster
		- x-nearenddevice=SEPA45630BB1748
		- x-nearendaddr=+36110009020
		- x-farendrefci=25252350
		- x-farendclusterid=StandAloneCluster
		- x-farenddevice=SEP100000009100
		- x-farendaddr=+36110009100
	
	
	
	'x-refci' contains the call leg ID which is the int representation (ID) of the call.
	
	You can find this leg ID in CiscoJtapi*.log
	
		539: 2020-02-28 07:47:00 CET %JTAPI-PROTOCOL-7-UNK:(P1-10.51.51.34) received Event: com.cisco.cti.protocol.NewCallEvent {
		  eventSequence                        = 13
		  lineCallManagerID                    = 1
		  lineID                               = 1590
		  lineHandleSpecified                  = true
		  deviceName                           = SEPA45630BB1748
		  callCallManagerID                    = 1
		  callLegID                            = 25252351								<<<< leg ID
		  globalCallManagerID                  = 1
		  callID                               = 21172 									<<<<< Cisco call ID
	
	
	Cisco call can be retrieved from provider by leg ID:
	
	
	--> com.andtek.andphone.sip.SIPTrunk.processAck(...)
		--> jtapiProvider = JTAPIServlet.getAndtekProvider((CiscoProvider) phone.getTerminal().getProvider());
			--> call = jtapiProvider.getCall(Integer.parseInt(callID))
				------- if call not found --------
					- try to get call from an active terminale connection (FALLBACK)
						------- if call found --------
							callID = 'sip' + call ID
						------- if call STILL not found --------
							callID = 'csip' + call leg ID
			
SEE ALSO:	What is 'csip...' call ID?
			
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is 'csip...' call ID?
==========================
During initiating a recording call information collected from 2 sources:
1. JTAPI 
2. SIP

If call retrieved from SIP information cannot be find in existing calls that means this call not detected before by JTAPI
(maybe terminal not observed by JTAPI).

In this case APAS generates a call ID from leg ID:			csip + CALL_LEG_ID



-------------------------------------------------------------------------------------------------------------------------------------
Structure of REC file
=====================
MOVED INTO:	source_code_discovery/Recording.txt

From: com.andtek.andphone.recorder.Recording.java



If filename ends with '.rec'
----------------------------
File contains header info and audio data.

Endian:	little endian

SUPER HEADER (at position 0)
	- 'AREC' (4 bytes fixed string)
	- version (int in 4 bytes)

HEADER	(at position 288)
	if version >= 3
		- id (int in 4 bytes)
	if version >= 2
		- keep (int in 4 bytes)
		- lastAction (int in 4 bytes)
		- id (int in 4 bytes)
	- start (int in 4 bytes)
	- end (int in 4 bytes)
	- originalLastAction (int in 4 bytes)
	- callingParty (0 terminated string from 24 bytes)
	- calledParty (0 terminated string from 24 bytes)
	- phoneip (0 terminated string from 24 bytes)
	- origCallingParty (0 terminated string from 24 bytes)
		if origCallingParty contains '.' then it's a remote IP
			- remoteip = origCallingParty
			- origCallingParty = ""
			- initiator (0 terminated string from 24 bytes)
		else
			- origCalledParty (0 terminated string from 24 bytes)
	- status (int in 4 bytes)
	- signaling (int in 4 bytes)
	- codec (int in 4 bytes)
	- originalKeep (int in 4 bytes)
	- audiolength (int in 4 bytes)
	- keySize (int in 4 bytes)
		if keySize = 0
			- keySize = ENCRYPTION_ALGORITHM_LENGTH_128 (128)

AUDIO	(at position 512)

If filename ends with '.spx'
----------------------------
File contains only audio data.

- id = getIDFromFilename(filename)
- record will be read from rec_call table



-------------------------------------------------------------------------------------------------------------------------------------
How recordings can be deleted?
==============================
SEE ALSO:	Writing/changing rec_call table

- deleted from database:
	- GdprService
		--> com.andtek.andphone.api.rest.controllers.gdpr.GdprController.erasure(...)
			--> com.andtek.andphone.api.services.gdpr.GdprService.deleteGdprRecors(...)
				--> GdprService.deleteRecordingEntry(...)
		

	- RecorderApiService 													// REST API
		- deleteRecording(int recid)										// only setting storage profile to 'DeleteStorageProfileID'
		- deleteRecording(int recid, String callTable)						// only setting storage profile to 'DeleteStorageProfileID'
		
	- com.andtek.andphone.recorder.Admin									// background processing
		- processAction(ConnectionBean connection)							// FILE + DB
		- recorderBackgroundProcessing()									// SEE ALSO: Post-processing recorded media
																								
																						
	- AdminHelper
		--> dbDeleteRecording(int recID)									// from background processing (see above)
		--> dbDeleteRecordingByStatusAndKeep(int status,int profileId)		// from background processing (see above)
		
	- com.andtek.andphone.recorder.gwtapp.server.RPCrecorderServiceImpl		// From GWT UI
		--> RemoteDeleteRecordingFiles
			

-------------------------------------------------------------------------------------------------------------------------------------
How calls are identified by independent <recordCall> messages?
==============================================================
- C++ recorder notified about call by APAS via recordCall messages.

- If recorder gets information about a call it creates a new entry into 'calls' chain and into rec_call DB table.

- During processig next messages it identifies incoming call information from 'calls' chain using 

		find_jtapi_terminal_call(const char *terminal, const char *jtapi_callID, int doref)

	which compares incoming callID and terminal with cached entries in the chain.
	
		THIS COMPARATION IS CASE-SENSITIVE! (till v 6.2.2)
		
	--> recordCall(...)
		--> call = find_jtapi_terminal_call(terminal, callID, true)
			- LOG:		->find_jtapi_terminal_call(...
			
				2020-05-07 08:03:52,190: 4: ->find_jtapi_terminal_call(CSFABOEHLKE,sip1963074/1)
			
			--> lock_calls();
			----------------- enumeration of calls chain -------------------
				- LOG:		find_jtapi_terminal_call check for call (
			
					2020-05-07 08:03:52,190: 4:   find_jtapi_terminal_call check for call (CSFSDrescher,sip1963066/1,0)
				
				---------------- if call->type == CALLTYPE_JTAPI and incoming terminal == call->terminal
					-------------------- if incoming jtapi_callID == call->jtapi_callID ---------------------
						--> exit from loop: FOUND
					- 'csip' call check - LOG:	find_jtapi_terminal_call found csip call for same terminal (...
					
				- end of function - LOG:	<-find_jtapi_terminal_call(...
				
		------------- if call == NULL -----------------
		--> call = call_new(CALLTYPE_JTAPI, callID, 0, 0, 0, 0, 0, 0)				// creating new call, id = 0
		--> add_call(call)														 // adding to calls chain
		
						

						
-------------------------------------------------------------------------------------------------------------------------------------
dbID=0 on the 2nd recordCall
============================
SEE ALSO:		How calls are identified by independent <recordCall> messages?

If 2nd recordCall contains the same callID but different terminal then call cannot be identified by find_jtapi_terminal_call()

	[2020-05-07 08:03:52,189] [DEBUG] [ObserverThread(com.andtek.andphone.recorder.PhoneCallObserver@7dc97e76)] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFABOEHLKE" callID="sip1963074/1" callingParty="6046024787" calledParty="96044432261" callingPartyName="Amanda Boehlke" calledPartyName="" originalCallingParty="2341" originalCalledParty="96044432261" lastRedirectingParty="" initiated="true"/>]
	[2020-05-07 08:03:52,193] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip1963074/1" dbID="1636368" state="1"/>
	[2020-05-07 08:03:54,137] [DEBUG] [APAS-defaultWorker-25] [XMLSocket.java:426] - XML_SOCKET:sending XML [<recordCall terminal="CSFABoehlke" callID="sip1963074/1" srcIP="192.168.1.94" srcPort="34584"/>]
	[2020-05-07 08:03:54,138] [DEBUG] [APAS-SnifferConnection] [XMLSocket.java:426] - XML_SOCKET:received message: <recordCallResponse code="0" string="OK" callID="sip1963074/1" dbID="0" state="0"/>
	...

and in this case a new call created 	

-------------------------------------------------------------------------------------------------------------------------------------
Writing recording to file
=========================

LOG about starting file write:

	2020-02-28 07:47:10,069: 3: |found Call_1 0,db:104 980 (+36110009100,+36110009020) [0]Resyncing RTP because new stream detected [call-id=104/sip21172/1, dir=1, ssrc=-1058530648]
	2020-02-28 07:47:10,069: 2: Starting to record a stream [call-id=104/sip21172/1, dir=1]
	2020-02-28 07:47:10,069: 1: Setting up Disk_thread for call dbId: 104 (ref=1) direction 1 initializing 
	
SEE ALSO:	Packet sniffing	
	
Packets received and UPD packet recognized. And then...
-------------------------------------------------------
--> handle_udp()
	- if packet is a duplicate to the last, ignore it
	- Ignore RFC2833 (RTP Events, e.g. DTMF tones) packets
	- finding call matches with packet
	-------------- DIR_IN/DIR_OUT ---------------------
		------------- DIR_IN ---------------
		--> call=find_rtp_call(ip->daddr,udp->dest,ip->saddr,udp->source)
		------------- DIR_OUT ---------------
		--> call=find_rtp_call(ip->saddr,udp->source,ip->daddr,udp->dest)
		
		------------------ if call found and not duplicated -------------------
		- getting who: ACTION_RECORD_CALLER or ACTION_RECORD_CALLED?
		
		- LOG: |found Call_...
		
			2020-02-28 07:47:10,069: 3: |found Call_1 0,db:104 980 (+36110009100,+36110009020) [0]Resyncing RTP because new stream detected [call-id=104/sip21172/1, dir=1, ssrc=-1058530648]
	
		

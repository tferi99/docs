===============================================
JTAPI Dynamic Presence subscription managements
===============================================

- Basics
- Configuration
- Server side
- Calculation of client side presence management intervals (WAC)
- Troubleshooting

--------------------------------------------------------------------------------------------------------------------------
Basics
======
Server provides presence information to clients. 

Presence information generated by different presence sources but server provides  it via unified abstract layer.

Supported presence types are:
- dynamic JTAPI
- CUPS
- Exchange

- Subscriptions:
	- Presence information can be accessed with subscriptions.
	- For performance and resource optimization subscriptions are allocated dynamically (on-demand) and they are destroyed if not used any more.

- Cleanup:	
	- Server stores subscriptions into a map. 
	- Every subscription has age information and a cleanup job removes old subscritions.
	- If a client uses a subscription then it sends keep-alive (or subscription update) signal regurarily which reset age information 
		of subscription.
	- ONLY keep-alive signals update age information of subscriptions



--------------------------------------------------------------------------------------------------------------------------
Configuration
=============
Presence Subscription Time:

	APAS/Client/Configuration/[Presence Configuration]/Presence Subscription Time
	
	Default value is: 600 		(com.andtek.andphone.presence.PresenceConsts.DEFAULT_PRESENCE_KEEP_TIME)

Presence GC loop period:
	
	com.andtek.andphone.presence.PresenceConsts.PRESENCE_GC_PERIOD = 30

Maximum age of presence subscription entries (without keep-alive):

	maxAge = PresenceSubscriptionTime + PRESENCE_GC_PERIOD
	

--------------------------------------------------------------------------------------------------------------------------
Server side
===========
- Subscription store:		DynamicJtapiPresenceServiceImpl.subscriptions

- New subscription:
	--> com.andtek.andphone.webmvc.webattendant.controllers.DirectoryController.search(dirId, search)
		--> directory = DirectoryServiceImpl.findDirectoryById(dirId)
		--> result = DirectoryServiceImpl.search(dirId, searchQuery, ...)
		--> WebDirectoryPresenceSubscriptionService.subscribe(result, connection)
			--> contacts = searchResult.getContacts()
			--> eventReceiver = connection.getWebPresenceEventReceiver()
			--> webPresenceObservationPool = WebPresenceObservationPool.createInstance(connection)
			--> profile = connection.getWebProfile()
			----------------- loop on cotacts ------------------
				--> processContact(contact, eventReceiver, webPresenceObservationPool)
					--> detailsMap = contact.getDetails()
						---------------- iterate over details map values -------------------
							- looking for 'Presence DN' attibute
							------------------- if detail is presence DN ---------------------
								--> WebDirectoryPresenceSubscriptionService.doTelephonyPresenceSubscription(contact, detail, eventReceiver, webPresenceObservationPool)
									- identifier from detail
									------------------ if identifier is JTAPI controlled ---------------------
										--> UnifiedWebPresenceServiceImpl.register(identifier, eventReceiver, webPresenceObservationPool, WebPresenceTypeEnum.JTAPI)
											--------------- if presence type is JTAPI ----------------------
												--> JtapiWebPresenceRegistrator.register(identifier, receiver, webPresenceObservationPool)
													- pdn = new PGroupDN(identifier)
													--> subscriptionList = DynamicJtapiPresenceServiceImpl.registerSubscription(phoneNumber = pdn, receiver)
														- addressList = getAddresses(phoneNumber)
														------------ loop on addressList --------------
															--> subscription = doRegisterSubscription(address, listener)
																-------------------- synchronized (subscriptions) ---------------------
																	--> subscriptions.put(getKeyForSubscriptionCache(subscription.getPhoneNumber()), subscription)					// subsript
																--> event = new DynamicJtapiPresenceEvent(this, subscription, DynamicJtapiPresenceEvent.CAUSE_STANDARD, CiscoAddrEv.class.getSimpleName())
																--> sendPresenceEvent(event, listener)
																	--> [client notification]
																	

- [client notification] and presence event handling:

- generation of DynamicJtapiPresenceEvent

	CALL EVENTS ==> DynamicJtapiPresenceCallObserver.callChangedEvent()
		--> DynamicJtapiEventProcessor.handle..Ev()
			--> caller = event.getConnection().getAddress()
				--> subscription = getDynamicJtapiPresenceSubscriptionByAddress(caller)
				---------------------------- if subscription found -----------------------------
					--> updateState(ext, ....)
					--> DynamicJtapiEventProcessor.fireObservers(new DynamicJtapiPresenceEvent(...))
						--> DynamicJtapiPresenceServiceImpl.sendPresenceEvent(event);
							- get listeners
							- send new DynamicJtapiPresenceEvent[] to event queue



- events for WebAttendant

	- WebAttendantPresenceEventHandler created for every WebAttendantConnection.
		Constructor:
		
			this.presenceEventHandler = new WebAttendantPresenceEventHandler(this)


	- WebAttendantPresenceEventHandler bound to event sources in:		WebDirectoryPresenceSubscriptionService.subscribe(...)
	
		--> eventReceiver = connection.getWebPresenceEventReceiver()
			...
			--> processContact(contact, eventReceiver, webPresenceObservationPool)
				--> doTelephonyPresenceSubscription(contact, detail, eventReceiver, webPresenceObservationPool)
					--> UnifiedWebPresenceService.register(identifier, eventReceiver, webPresenceObservationPool, WebPresenceTypeEnum.JTAPI)
						--> JtapiWebPresenceRegistrator.register(identifier, receiver, webPresenceObservationPool)
								...
								--> subscriptionList = DynamicJtapiPresenceServiceImpl.registerSubscription(phoneNumber = pdn, receiver)
									- addressList = getAddresses(phoneNumber)
									------------ loop on addressList --------------
										--> subscription = doRegisterSubscription(address, listener)
											--> DynamicJtapiPresenceSubscription.addPresenceListener(listener)
	
	
	- sending events to WebAttendant:
		--> EventQueueWorker.run()
			----------------- loop on eventsList --------------------
				--> handleEvent(entry)
					...
					--> DynamicJtapiPresenceServiceImpl.handleEvents(APASEvent[] events, Object ob)
						--> WebAttendantPresenceEventHandler.dynamicJtapiPresentEvent(DynamicJtapiPresenceEvent jtapiPresenceEvent)
						
							- PresenceWebEvt event = new PresenceWebEvt(presenceItem)																
							
							--> sendPresenceEvent(event)
								--> EventBroadcaster.broadcast(connection.getUsername(), event, ClientType.webattendant)						<<<<<<< PUSH PresenceWebEvt message to WAC by username

	
	
	
- Subscription cleanup:

	- subscriptions are stored into:
	
		com.andtek.andphone.ccm.jtapi.presence.impl.DynamicJtapiPresenceServiceImpl.subscriptions
		
		It's a map[phoneNumber, DynamicJtapiPresenceSubscription]

	--> com.andtek.andphone.utils.Timer.run()		(extends APASThread)
		--> com.andtek.andphone.global.Module.timerExpired(...)
			-------------------------- loop with subscriptionVerifyCount ---------------------------------					
			- if subscriptionVerifyCount % N == 0																											<<<<<<<< cleanup polling time (PRESENCE_GC_PERIOD)
				--> DynamicJtapiPresenceServiceImpl.verifySubscriptions()
					--> expiredSubscriptions = getExpiredSubscriptions()
						--------------------- loop on expiredSubscriptions -------------------------
							--> removeSubscription(subscription)


- Presence subscription age:	

	maxAge = PresenceSubscriptionTime + PRESENCE_GC_PERIOD

- Keep-alive:

	- client:	
		GlobalEffects.appCsrfInitiated$
		  ==> updatePresenceSubscriptions()
			--> PresenceEffects.updatePresenceSubscriptions$
				--> doUpdatePresenceSubscriptions(profile, presenceItems)
					--> PresenceService.bulkUpdateSubscription(presenceItems)
						HTTP ==> /presence/bulkUpdateSubscription with presence items






--------------------------------------------------------------------------------------------------------------------------
Calculation of client side presence management intervals (WAC)
==============================================================
/**
 * CALCULATION OF CLIENT SIDE PRESENCE MANAGEMENT INTERVALS
 * ========================================================
 * If an entry cleanup mechanism based on keep-alive signal than maximum age of entries and frequency of keep-alive signal theoretically can be the same.
 * In practice keep-alive signals should be sent a little bit more often. Here specify:      KEEP_ALIVE_RATIO (keepAlive / age) = 0.8
 *
 * Ideal cleanup loop frequency is infinite (loop time is 0). For performance consideration in practice we set cleanup loop time to 1/2 - 1/10 of item age.
 *
 * There are two kind of entries which managed here:
 *  - server side subscriptions
 *  - client side presence entries in the store
 *
 *  Entries are cleaned up if they are not used any more. Usage dependency is:
 *
 *    client component ---> presence store entry ---> server side subscription
 *
 * Entries contain age information which refreshed regularly by consumer:
 *
 *  - server side subscriptions are refreshed by client by store entries
 *  - store entries are refreshed by components
 *    For example in directory widget by search result entries.
 *
 *  Calculation of ages and frequency of cleanup signals is very important.
 *  False calculation leads to loss of information (non-rendered presence, deleted subscription)
 *  or performance issues of stuck resources.
 *
 * Presence subscription on server
 * -------------------------------
 * - Expected (minimum) age of subscriptions on server is configure in user profile:    profile.presenceSubscriptionTime
 *
 * - Interval of subscription update signal loop (PresenceSubscriptionUpdateInterval):
 *
 *      PresenceSubscriptionUpdateInterval = profile.presenceSubscriptionTime * KEEP_ALIVE_RATIO
 *
 * Presence in client store
 * ------------------------
 * - Age of presence entries in the client store
 *    Minimum age of client side presence entries in the store should be greater than real maximum age of server subscriptions.
 *    Real maximum age of server subscriptions is greater than expected value because server cleanup based on a polling loop (SERVER_PRESENCE_CLEANUP_INTERVAL)
 *    Maximum age of subscriptions on server (without update keep-alive):
 *
 *      PresenceSubscriptionUpdateInterval <= RealMaxServerSubscriptionAge <= (profile.presenceSubscriptionTime + SERVER_PRESENCE_CLEANUP_INTERVAL) * 1000
 *
 *    Store cleanup should not clear jounger items, otherwise server still has subscription but there is a gap where client cannot render presence information.
 *
 *    We specify a little bit grater value (RealMaxServerSubscriptionAge + SERVER_PRESENCE_CLEANUP_INTERVAL):
 *
 *      OldPresenceAge = profile.presenceSubscriptionTime + 2 * SERVER_PRESENCE_CLEANUP_INTERVAL)
 *
 *  - presence store keep-alive:
 *
 * - StoreCleanup interval:
 *
 *      OldPresenceAge * CLEANUP_RATIO
 *
 *    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *    NOTE: server values are in SECONDS but we use time values on client side in MILLISECONDS
 *    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 *    With default presenceSubscriptionTime = 600
 *      - PresenceSubscriptionUpdateInterval = 450
 *      - OldPresenceAge = 660
 *      - PresenceStoreKeepalive: 495
 *      - PresenceStoreCleanup: 165
 */


--------------------------------------------------------------------------------------------------------------------------
Troubleshooting
===============
- No JTAPI presence info about a phone:
	
	Check if phone controlled by your application user.
	
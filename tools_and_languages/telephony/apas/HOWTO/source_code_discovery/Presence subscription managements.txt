===============================================
JTAPI Dynamic Presence subscription managements
===============================================

- Basics
- Configuration
- Server side
- Client side
- Calculation of client side presence management intervals (WAC)
- Troubleshooting

--------------------------------------------------------------------------------------------------------------------------
Basics
======
Server provides presence information to clients. 

Presence information generated by different presence sources but server provides  it via unified abstract layer.

Supported presence types are:
- dynamic JTAPI
- CUPS
- Exchange

- Subscriptions:
	- Presence information can be accessed with subscriptions.
	- For performance and resource optimization subscriptions are allocated dynamically (on-demand) and they are destroyed if not used any more.

- Cleanup:	
	- Server stores subscriptions into a map. 
	- Every subscription has age information and a cleanup job removes old subscritions.
	- If a client uses a subscription then it sends keep-alive (or subscription update) signal regurarily which reset age information 
		of subscription.
	- ONLY keep-alive signals update age information of subscriptions



--------------------------------------------------------------------------------------------------------------------------
Configuration
=============
Presence Subscription Time:

	APAS/Client/Configuration/[Presence Configuration]/Presence Subscription Time
	
	Default value is: 600 		(com.andtek.andphone.presence.PresenceConsts.DEFAULT_PRESENCE_KEEP_TIME)

Presence GC loop period:
	
	com.andtek.andphone.presence.PresenceConsts.PRESENCE_GC_PERIOD = 30

Maximum age of presence subscription entries (without keep-alive):

	maxAge = PresenceSubscriptionTime + PRESENCE_GC_PERIOD
	

--------------------------------------------------------------------------------------------------------------------------
Server side
===========
- Presence state of every contact stored into DynamicJtapiPresenceSubscription objects 

- Subscription objects are cached here:		DynamicJtapiPresenceServiceImpl.subscriptions

- New subscriptions are created on-demand during query commands which return contact information to clients (e.g. LDAP Directory search)

	- Clients are notified about new presence information via pushed messages, for example 'PresenceWebEvt' WebSocket message to WebAttendant

	- Search queries create new subscriptions ONLY for contacts which don't exist in subscription cache
	
	- Pushed messages are ONLY sent during new subscription. That means:
	
		- contact search DON'T create new subscriptions about cached contacts
		- contact search DON'T create pushed messages about cached contacts
		- if a client needs information about cached contact it should send a request to server, like: WAC PresenceService.forcePushPresenceItems()
		
- Unused subscriptions are cleaned up automatically
	- a subscription has an age value
	- age has been reset by clients with keep-alive signals
	- usused item (which not refreshed by keep-alive) are deleted by a background job reqularly
	

- New subscription:
	- REST:	/search		params: dirId, search

	--> com.andtek.andphone.webmvc.webattendant.controllers.DirectoryController.search(dirId, search)
		--> directory = DirectoryServiceImpl.findDirectoryById(dirId)
		--> result = DirectoryServiceImpl.search(dirId, searchQuery, ...)
		--> WebDirectoryPresenceSubscriptionService.subscribe(result, connection)
			--> contacts = searchResult.getContacts()
			--> eventReceiver = connection.getWebPresenceEventReceiver()
			--> webPresenceObservationPool = WebPresenceObservationPool.createInstance(connection)
			--> profile = connection.getWebProfile()
			----------------- loop on cotacts ------------------
				--> processContact(contact, eventReceiver, webPresenceObservationPool)
					--> detailsMap = contact.getDetails()
						---------------- iterate over details map values -------------------
							- looking for 'Presence DN' attibute
							------------------- if detail is presence DN ---------------------
								--> WebDirectoryPresenceSubscriptionService.doTelephonyPresenceSubscription(contact, detail, eventReceiver, webPresenceObservationPool)
									- identifier from detail
									------------------ if identifier is JTAPI controlled ---------------------
										--> UnifiedWebPresenceServiceImpl.register(identifier, eventReceiver, webPresenceObservationPool, WebPresenceTypeEnum.JTAPI)
											--------------- if presence type is JTAPI ----------------------
												--> JtapiWebPresenceRegistrator.register(identifier, receiver, webPresenceObservationPool)
													- pdn = new PGroupDN(identifier)
													--> subscriptionList = DynamicJtapiPresenceServiceImpl.registerSubscription(phoneNumber = pdn, receiver)
														- addressList = getAddresses(phoneNumber)
														------------ loop on addressList --------------
															--> subscription = doRegisterSubscription(address, listener)
																-------------------- synchronized (subscriptions) ---------------------
																	--> subscriptions.put(getKeyForSubscriptionCache(subscription.getPhoneNumber()), subscription)					// subsript
																--> event = new DynamicJtapiPresenceEvent(this, subscription, DynamicJtapiPresenceEvent.CAUSE_STANDARD, CiscoAddrEv.class.getSimpleName())
																--> sendPresenceEvent(event, listener)
																	--> [client notification]
																	

- [client notification] and presence event handling:

	Ggeneration of presence (DynamicJtapiPresenceEvent) events:

	PHONE CALL EVENTS ==> DynamicJtapiPresenceCallObserver.callChangedEvent()
		--> DynamicJtapiEventProcessor.handle..Ev()
			--> caller = event.getConnection().getAddress()
				--> subscription = getDynamicJtapiPresenceSubscriptionByAddress(caller)
				---------------------------- if subscription found -----------------------------
					--> updateState(ext, ....)
					--> DynamicJtapiEventProcessor.fireObservers(new DynamicJtapiPresenceEvent(...))
						--> DynamicJtapiPresenceServiceImpl.sendPresenceEvent(event);
							- get listeners
							- send new DynamicJtapiPresenceEvent[] to event queue



- events for clients (WebAttendant):

	- WebAttendantPresenceEventHandler created for every WebAttendantConnection.
		Constructor:
		
			this.presenceEventHandler = new WebAttendantPresenceEventHandler(this)


	- WebAttendantPresenceEventHandler bound to event sources in:		WebDirectoryPresenceSubscriptionService.subscribe(...)
	
		--> eventReceiver = connection.getWebPresenceEventReceiver()
			...
			--> processContact(contact, eventReceiver, webPresenceObservationPool)
				--> doTelephonyPresenceSubscription(contact, detail, eventReceiver, webPresenceObservationPool)
					--> UnifiedWebPresenceService.register(identifier, eventReceiver, webPresenceObservationPool, WebPresenceTypeEnum.JTAPI)
						--> JtapiWebPresenceRegistrator.register(identifier, receiver, webPresenceObservationPool)
								...
								--> subscriptionList = DynamicJtapiPresenceServiceImpl.registerSubscription(phoneNumber = pdn, receiver)
									- addressList = getAddresses(phoneNumber)
									------------ loop on addressList --------------
										--> subscription = doRegisterSubscription(address, listener)
											--> DynamicJtapiPresenceSubscription.addPresenceListener(listener)
	
	
	- sending events to WebAttendant:		PresenceWebEvt
		--> EventQueueWorker.run()
			----------------- loop on eventsList --------------------
				--> handleEvent(entry)
					...
					--> DynamicJtapiPresenceServiceImpl.handleEvents(APASEvent[] events, Object ob)
						--> WebAttendantPresenceEventHandler.dynamicJtapiPresentEvent(DynamicJtapiPresenceEvent jtapiPresenceEvent)
						
							- PresenceWebEvt event = new PresenceWebEvt(presenceItem)																
							
							--> sendPresenceEvent(event)
								--> EventBroadcaster.broadcast(connection.getUsername(), event, ClientType.webattendant)						<<<<<<< PUSH PresenceWebEvt message to WAC by username

	
	
	
- Subscription cleanup:

	- subscriptions are stored into:
	
		com.andtek.andphone.ccm.jtapi.presence.impl.DynamicJtapiPresenceServiceImpl.subscriptions
		
		It's a map[phoneNumber, DynamicJtapiPresenceSubscription]

	--> com.andtek.andphone.utils.Timer.run()		(extends APASThread)
		--> com.andtek.andphone.global.Module.timerExpired(...)
			-------------------------- loop with subscriptionVerifyCount ---------------------------------					
			- if subscriptionVerifyCount % N == 0																											<<<<<<<< cleanup polling time (PRESENCE_GC_PERIOD)
				--> DynamicJtapiPresenceServiceImpl.verifySubscriptions()
					--> expiredSubscriptions = getExpiredSubscriptions()
						--------------------- loop on expiredSubscriptions -------------------------
							--> removeSubscription(subscription)


	- Presence subscription age:	

		maxAge = PresenceSubscriptionTime + PRESENCE_GC_PERIOD

	- Keep-alive:

		- client:	
			GlobalEffects.appCsrfInitiated$
			  ==> updatePresenceSubscriptions()
				--> PresenceEffects.updatePresenceSubscriptions$
					--> doUpdatePresenceSubscriptions(profile, presenceItems)
						--> PresenceService.bulkUpdateSubscription(presenceItems)
							HTTP ==> /presence/bulkUpdateSubscription with presence items



--------------------------------------------------------------------------------------------------------------------------
Client side
===========
PUSHED message:		PresenceWebEvt


- Presence items stored into feature Entity node:		presence

	where ID:	<DN>_<Presence Type>			for example:	36110009100_JTAPI
	
	
	--> AtmosphereService.onMessage()
		- on PresenceWebEvt
			--> store.dispatch(PresenceActions.itemReceived({item: data.presenceItem}))
				--> presenceReducer - upsertOne															// merge into 'presence' entity
	

- Presence client store cleanup and server keep-alive:
	A background job removes ununsed items from store and sends keep-alive signals to server regularly.
	
	- It updates server side presence items via POST REST message
	- it removes old items from store
	- call itself (infinite loop)


	presenceStoreCleanupInit --> presenceStoreCleanup 
	   ^             |
	   |             |
	   |-------------|
	   
	- job started during startup - in handler effect of AppCsrfInitiatedAction
		
		
	--> MainComponent.onInit() action: AppDataLoadRequestedAction ==>
		--> GlobalEffect.appDataLoadRequested REST /reload ==> APAS
			--> action AppCsrfInitiatingAction ==>
				--> GlobalEffect.appCsrfInitiating$ action: AppCsrfInitiatedAction ==>
					--> GlobalEffect.appCsrfInitiated$ 
						--> A LOT OF ACTIONS to features ==>
						
						------------------------------------- presence store cleanup / keep-alive to server -----------------------
						--> PresenceEffects.presenceStoreCleanupInit$
								<- selectUserProfile()																						// profile with input parameters
								<- selectOldPresences																						// old presences from store (where last keep-alive is elder then (now - oldAge))
							--> doUpdatePresenceSubscriptions(profile, presenceItems)
								--> presenceService.bulkUpdateSubscription(presenceItems, profile)
									--> retryInterval = getPresenceSubscriptionKeepaliveIntervalMsecs(profile) / RETRY_FACTOR				// 
									--> POST /presence/bulkUpdateSubscription', presenceItemsToSend											// POST to server - max retry: 3
								--> doPresenceStoreCleanupInit(profile)																		// call this job again (later)
									--> timeout => store.dispatch(presenceStoreCleanupInit({now: Date.now()})), cleanupInterval)			// presenceStoreCleanup
								 --> PresenceReducer.on(presenceStoreCleanup({oldPresences}))
									--> updating lastKeepAlive in store if empty															// lat keepalive if empty
									--> oldIds = IDs from old presence items
									--> removeMany(oldIds)
						-----------------------------------------------------------------------------------------------------------
						--> action: AppDataLoadedAction ==>
							--> GlobalEffect.appDataLoaded$
								--> AtmosphereService.reSubscribe()																			// subscription to WebSocket
									--> unsubscribe()
									--> subscribe() action: WebSocketConnectedAction ==>
										--> GlobalEffect.webSocketConnected$
											--> PresenceService.forcePushPresenceItems()													<<<<<<<<<<<<<<<<< request to APAS to get my presence cache items (sent via WebSocket)
							
					
- presence store keep-alive:

	DirectoryComponent updates 'lastKeepAlive' in all presence items of store which contained by Directory widget as serch result.
	So if there is no Directory widget opened store keepalive won't created.

	--> DirectoryComponenent.onInit()
		--> sendPresenceStoreKeepAliveUpdate()
			--> action presenceStoreKeepAliveUpdate({result: this.dirSearchResult})
			
				--> PresenceReducer.on(presenceStoreKeepAliveUpdate)
					- changes[] <- {id, changes: {lastKeepAlive: now}} 
					--> updateMany(changes)
			
		--> timeout: sendPresenceStoreKeepAliveUpdate()																// call itself infinitely
					
--------------------------------------------------------------------------------------------------------------------------
Calculation of client side presence management intervals (WAC)
==============================================================
/**
 * CALCULATION OF CLIENT SIDE PRESENCE MANAGEMENT INTERVALS
 * ========================================================
 * If an entry cleanup mechanism based on keep-alive signal than maximum age of entries and frequency of keep-alive signal theoretically can be the same.
 * In practice keep-alive signals should be sent a little bit more often. Here specify:      KEEP_ALIVE_RATIO (keepAlive / age) = 0.8
 *
 * Ideal cleanup loop frequency is infinite (loop time is 0). For performance consideration in practice we set cleanup loop time to 1/2 - 1/10 of item age.
 *
 * There are two kind of entries which managed here:
 *  - server side subscriptions
 *  - client side presence entries in the store
 *
 *  Entries are cleaned up if they are not used any more. Usage dependency is:
 *
 *    client component ---> presence store entry ---> server side subscription
 *
 * Entries contain age information which refreshed regularly by consumer:
 *
 *  - server side subscriptions are refreshed by client by store entries
 *  - store entries are refreshed by components
 *    For example in directory widget by search result entries.
 *
 *  Calculation of ages and frequency of cleanup signals is very important.
 *  False calculation leads to loss of information (non-rendered presence, deleted subscription)
 *  or performance issues of stuck resources.
 *
 * Presence subscription on server
 * -------------------------------
 * - Expected (minimum) age of subscriptions on server is configure in user profile:    profile.presenceSubscriptionTime
 *
 * - Interval of subscription update signal loop (PresenceSubscriptionUpdateInterval):
 *
 *      PresenceSubscriptionUpdateInterval = profile.presenceSubscriptionTime * KEEP_ALIVE_RATIO
 *
 * Presence in client store
 * ------------------------
 * - Age of presence entries in the client store
 *    Minimum age of client side presence entries in the store should be greater than real maximum age of server subscriptions.
 *    Real maximum age of server subscriptions is greater than expected value because server cleanup based on a polling loop (SERVER_PRESENCE_CLEANUP_INTERVAL)
 *    Maximum age of subscriptions on server (without update keep-alive):
 *
 *      PresenceSubscriptionUpdateInterval <= RealMaxServerSubscriptionAge <= (profile.presenceSubscriptionTime + SERVER_PRESENCE_CLEANUP_INTERVAL) * 1000
 *
 *    Store cleanup should not clear jounger items, otherwise server still has subscription but there is a gap where client cannot render presence information.
 *
 *    We specify a little bit grater value (RealMaxServerSubscriptionAge + SERVER_PRESENCE_CLEANUP_INTERVAL):
 *
 *      OldPresenceAge = profile.presenceSubscriptionTime + 2 * SERVER_PRESENCE_CLEANUP_INTERVAL)
 *
 *  - presence store keep-alive:
 *
 * - StoreCleanup interval:
 *
 *      OldPresenceAge * CLEANUP_RATIO
 *
 *    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *    NOTE: server values are in SECONDS but we use time values on client side in MILLISECONDS
 *    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 *    With default presenceSubscriptionTime = 600
 *      - PresenceSubscriptionUpdateInterval = 450
 *      - OldPresenceAge = 660
 *      - PresenceStoreKeepalive: 495
 *      - PresenceStoreCleanup: 165
 */


--------------------------------------------------------------------------------------------------------------------------
Troubleshooting
===============
- No JTAPI presence info about a phone:
	
	Check if phone controlled by your application user.
	
Request processing
------------------
Request will be processed by rules in web.xml generated by AndroMDA.

- There are filters to populate GUI pages:

	<filter>
		<filter-name>${USECASE_PACKAGE}.${PAGE}Populator</filter-name>
		<filter-class>{USECASE_PACKAGE}.${PAGE}Populator</filter-class>
	</filter>

    <filter-mapping>
        <filter-name>{USECASE_PACKAGE}.${PAGE}Populator</filter-name>
        <url-pattern>{USECASE_PATH}/${PAGE}.jsf</url-pattern>
    </filter-mapping>		

- There are servlets for usecases:	

    <servlet>
        <servlet-name>${USECASE_PACKAGE}.${USECASE}</servlet-name>
        <servlet-class>${USECASE_PACKAGE}.${USECASE}</servlet-class>
    </servlet>
	
    <servlet-mapping>
        <servlet-name>${USECASE_PACKAGE}.${USECASE}</servlet-name>
        <url-pattern>${USECASE_PACKAGE}.${use-case}.jsf</url-pattern>
    </servlet-mapping>
	
	
LifeCycle of usecase
--------------------
1.a Calling usecase by menu
	
	Menu item generated into menu.xhtml:
	
		<t:navigationMenuItem itemLabel="#{messages['<USECASE>.title']}" action="#{<USECASE-CONTROLLER>.<USECASE>}" icon="/images/next-yellow.gif" />

	Menu calls <USECASE> method of controller (main entry point of usecase - see 2.)

1.b Calling usecase from a usecase: request submitted from the last client side page of previous usecase:

		http://<HOST/><CONTEXT_PATH>/<USECASE_PACKAGE>/<USECASE>.jsf
		
	and URL of usecase resolved by web.xml into servlet. Format os <USECASE>: 	
		
		use-case.jsf
	
	USECASE.jsf is USECASE servlet:

	    <servlet>
	        <servlet-name>org.tferi.jsftest.usecases.start.Start</servlet-name>
	        <servlet-class>org.tferi.jsftest.usecases.start.Start</servlet-class>
	    </servlet>
		
	    <servlet-mapping>
	        <servlet-name>org.tferi.jsftest.usecases.start.Start</servlet-name>
	        <url-pattern>/org/tferi/jsftest/usecases/start/start.jsf</url-pattern>
	    </servlet-mapping>
	

	USECASE servlet calls <USECASE>() method of <USECASE> controller (see 2.). 
 

2. First method of usecase: <USECASE> method of controller
	- getting request-form context ("form" variable  from ADF/Faces context - (<UseCase>FormImpl)
	- populating request-form
		- it gets previos usecase form from AdfFacesContext
		- it gets or creates current usecase form
		- it populates current usecase form from previous usecase form
		- it populates current usecase form from request parameters
		- it saves current usecase form into AdfFacesContext
	- <USECASE> method will be dispatched to the first state.
		
		
3. In server-side state 		

	Server side states are implemented as _<STATE>() methods in controller. These methods 
	receives event parameters in controller-calling forms.
	
	Tasks of this method:
	- deferrable events are called (calling model to process form parameters)
	- dispatching to the next state:
		- If next state is also a server-side state dispatching performed by a simple 
			direct call into next _<STATE>() method.
		- If next state is a client-side state ... see 4.


	You can process submitted values if outgoing transition connected to a server side state
	which contains controller function as deferrable event (parameter names in such controller method 
	must be correspond to submitted parameters).
		
4. After the last server-side state
	
	- In the last server-side state chain has been finished and outcome code of the next client-side 
		state will be returned.
	- This outcome code will be returned back to usecase servlet (through state method chain and entry 
		controller method).
	- Servlet gets URL by outcome code calling UseCaseForwards.getPath():
	
		String forwardPath = org.andromda.presentation.jsf.UseCaseForwards.getPath(controller.dataFlow6());

		For example:
		
			forwards.put("data-flow6-df6-input-page", "/org/tferi/jsftest/usecases/dataflowexample/dataflow6/df6-input-page.jsf");
     		
	- Servlet calls a redirect to call next client-side page:
	
        response.sendRedirect(request.getContextPath() + forwardPath);	

 	- Redirect generates a new request with the following URL:

		http://<HOST/><CONTEXT_PATH>/<USECASE_PACKAGE>/<USECASE-PAGE>.jsf

5. Populating next page
		
	Request will be processed by a filter to populate new page:

	    <filter-mapping>
	        <filter-name>org.tferi.jsftest.usecases.dataflowexample.dataflow6.Df6InputPagePopulator</filter-name>
	        <url-pattern>/org/tferi/jsftest/usecases/dataflowexample/dataflow6/df6-input-page.jsf</url-pattern>
	    </filter-mapping>	
		
	This URL will be handled by JSF and URL will be translated into:

		/<USECASE_PACKAGE>/<USECASE-PAGE>.xhtml

	
	NOTE: You can call by JSF, navigation-rule entries are generated into faces-config.xml for 
		every pages:
		
	   <navigation-rule>
			<navigation-case>
				<from-outcome>data-flow6-df6-input-page</from-outcome>
				<to-view-id>/org/tferi/jsftest/usecases/dataflowexample/dataflow6/df6-input-page.xhtml</to-view-id>
				<redirect/>
			</navigation-case>
		</navigation-rule>		

	Tasks:
		- form retrieved
		- form serialized into:
			<HOME>/Local Settings/Temp/<USER>/.andromda/jsf-cartridge/<SESSION>/form.ser
		- view variables (incoming signal parameters) populated as request attributes
		
6. On client side state a page will be rendered with a form, which will be filled and submitted by user.
	Form components has been generated from event parameters OF OUTGOING TRANSITION.
		
7. Submitting client-side state

	First 

	Submit creates a new request that will be (actually sent to the same page and) dispatched through 
	subsequent server side states till a client side state found (maybe in the next usecase).

	This is similar to entry point of usecase, the only difference is that another method will be called:
	
		controller.<USECASE><FORM>()
		
	but structure of this method is the same as entry method of usecase.

8. In the last state before final state

	Dispatch to the next usecase will be performed by direct calling of entry method of next usecase:
	
        forward = ((org.tferi.jsftest.usecases.dataflowexample.dataflow6.DataFlow6Controller)this.resolveVariable("dataFlow6Controller")).dataFlow6();
		
	
 	To pass form parameters:
	1. Implicite method: Add signal parameters to last signal (going into final state). This parameters 
		generated into first request-form as fields automatically.
	OR 
	2. Explicite mothod: Manually add fields to the first request-form of the next usecase with the 
		SAME NAME, so theses fields will be populated.
	

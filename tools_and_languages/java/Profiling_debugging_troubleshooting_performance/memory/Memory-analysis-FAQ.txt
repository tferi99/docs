===================
===================
Memory analysis FAQ
===================

- Memory analysis basics
- How to print memory info of JVM?
- How to create heap dump?
- How to analyse heap dump?
- How to compare heap dumps?
- Memory analysis with Eclipse MAT
- How to add Verbose Garbage Collection to logs?

-------------------------------------------------------------------------------------------------	
Memory analysis basics
======================
- Heap Dump
	A heap dump is a snapshot of the memory of a Java process at a certain point of time. 
	
- Shallow vs. Retained Heap

	- Shallow heap is the memory consumed by one object - WITHOUT references.
	- Retained set of X:	the set of objects which would be removed by GC when X is garbage collected. 
	- Retained heap of X:	the sum of shallow sizes of all objects in the retained set of X, i.e. memory kept alive by X. 

- Dominator Tree

	- An object x DOMINATES an object y if every path in the object graph from the start (or the root) node to y must go through x. 
	- The immediate dominator x of some object y is the dominator closest to the object y. 
	- A dominator tree is built out of the object graph. In the dominator tree each object is the immediate dominator of its children, 
		so dependencies between the objects are easily identified
	
- Garbage Collection Roots
		
	Garbage Collection Roots

SEE ALSO:	ECLIPSE/Help Contents/Memory Analyzer/Concepts	


-------------------------------------------------------------------------------------------------	
How to print memory info of JVM?
================================
jmap -heap <pid>


-------------------------------------------------------------------------------------------------	
How to create heap dump?
========================

- jmap

	jmap -dump:format=b,file=<filename> <pid>
	
	If it cannot connect to process use -F option. The reality is, the -F switch tells the JVM to use the Serviceability Agent interface for extracting the heap data. 
	THIS ALTERNATE INTERFACE IS EXTREMELY SLOW.
	
	NOTE:
	Dump that takes five minutes without the -F switch might take an hour with the -F switch. So, never use the -F switch, right? 
	There might be a circumstance where the JVM is hung in a way that such that the default interface does not work. If getting the heap dump is critical, 
	then it might be worth trying the -F switch. You would have to balance down-time against the value of understanding the root cause of the problem.
	
	
- jcmd
	
	jcmd <pid> GC.heap_dump <file-path>
	
		Apply -F - simirarly to jmap - if socket cannot be 
	
- JConsole

	- Connect to your JMX enabled instance
	- go to MBeans tab
	- com.sun.management/HotspotDiagnostic/Operations/[dumpHeap]
	- Fill in p0 parameter to name the Heap Dump method, for example:
	
			dumpHeap (p0 /tmp/apas.hprof p1 true)
			
	- press the dumpHeap button

	
- VisualVM

	- Connect to your JMX enabled instance
	- go to Monitor tab
	- press the HeapDump button
	- messagebox notifies end of action
	
	
- HPROF - profiling classes

	java -Xrunhprof[:options] ToBeProfiledClass
	OR
	java -agentlib:hprof=heap=sites ToBeProfiledClass

- on OutOfMemoryError

	Start VM with -XX:+HeapDumpOnOutOfMemoryError
	
	If OutOfMemoryError is thrown, VM generates a heap dump.	

	But it requires APPLICATION RESTART.
		
- Eclipse MAT:
	
	ECLIPSE/File/Acquire Heap Dump...
	
  OR
	
	ECLIPSE/File/New/Other.../Other/Heap Dump

	
- programmatically:

	The other way to use the HotSpotDiagnostic MBean is by invoking it programmatically from Java code.

		public static void dumpHeap(String filePath, boolean live) throws IOException {
			MBeanServer server = ManagementFactory.getPlatformMBeanServer();
			HotSpotDiagnosticMXBean mxBean = ManagementFactory.newPlatformMXBeanProxy(
			  server, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean.class);
			mxBean.dumpHeap(filePath, live);
		}
		
	Notice that an hprof file cannot be overwritten. If we fail to do so we'll get an exception:

		Exception in thread "main" java.io.IOException: File exists
			at sun.management.HotSpotDiagnostic.dumpHeap0(Native Method)
			at sun.management.HotSpotDiagnostic.dumpHeap(HotSpotDiagnostic.java:60)	

SEE ALSO:	https://www.baeldung.com/java-heap-dump-capture	
	
-------------------------------------------------------------------------------------------------	
How to analyse heap dump?
=========================

Static analysis for heap dumps
------------------------------

- MAT (Memory Analysis Tool - Eclipse extension) - !!!!!!!!!!!!!!!!! RECOMMENDED !!!!!!!!!!!!!!!!!!!!!!!!!!!

	The Eclipse Memory Analyzer is a fast and feature-rich Java heap analyzer that helps you find memory leaks and reduce memory consumption.
	
	- You can install it from Marketplace
	- Go to Memory Analysis perspective
	- File/Open 'Heap Dump...
	
	
- VisualVM
	
	- load HPROF file into VisualVM
	- you can browse classes and object instances
	- you can use OQL language to make queries
	- you can load another HPROF and make a comparison
	
- jhat	

		jhat <heap-dump-file>
		
	It opens a HTTP port to access information with browser.
	
Dinamic analysis
----------------
- VisualVM
	- Sampling		: not exact
	- Profiling 	: big performance impact
	
Analyis with logs
-----------------
SEE ALSO:	How to add Verbose Garbage Collection to logs?
	
-------------------------------------------------------------------------------------------------	
How to compare heap dumps?
==========================
- Create mutiple heap dumps 

- MAT

	On Histogram tab you can make a comparison (last button).

- VisualVM

	On classes page you can load another dumps.

-------------------------------------------------------------------------------------------------	
Memory analysis with Eclipse MAT
================================
Usable tools:

- Histogram - to get get shallow and retained heap grouped by class/superclass/class loader/package

	Tips:
	- order by retained heap
	- open a second histogram and click 'Compare to another Heap Dump'
	
- Dominator tree - to find dominator grouped by no/class/superclass/class loader/package
	Tips:
	- order by retained heap

- Threads	


SEE ALSO:
	https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer/

-------------------------------------------------------------------------------------------------	
Eclipse MAT OQL
===============
Basic OQL syntax is as follows:

	SELECT * FROM [ INSTANCEOF ]	<class_name> [ WHERE <filter-expression>]

- to select object instances of a class:

	SELECT * FROM <class_name>
	
	select * from java.lang.String
	
- to select class instance:

	SELECT * FROM OBJECTS <class_name>


-------------------------------------------------------------------------------------------------	
How to add Verbose Garbage Collection to logs?	
==============================================
- To activate “simple” GC Logging add JVM start-up arguments:

	-XX:+UseSerialGC -Xms1024m -Xmx1024m -verbose:gc

	NOTE:
		The important argument here is the -verbose:gc, which activates the logging of garbage collection information in its simplest form. 
		
		By default, the GC log is written to stdout and should output a line for every young generation GC and every full GC.
		For the purposes of our example, we've specified the serial garbage collector, the simplest GC implementation, via the argument -XX:+UseSerialGC.

		We've also set a minimal and maximal heap size of 1024mb, but there are, of course, more JVM parameters we can tune.

- To activate the detailed GC logging, we use the argument 

	-XX:+PrintGCDetails
	
  It provides:
	- Size of the young and old generation before and after each GC
	- The time it takes for a GC to happen in young and old generation
	- The Size of objects promoted at every GC
	- A summary of the size of the total heap	

- Adding Date and Time Information:

	-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
	
		OR from Java 9
	
	-Xlog:gc*::time
	
- Logging to a File:

	-Xloggc:/path/to/file/gc.log
	
		OR from Java 9
		
	-Xlog:gc:/path/to/file/gc.log
	
	
- Java 9: Unified JVM Logging:

	-Xlog:gc
	-Xlog:gc=debug
	-Xlog:gc=debug:file=gc.txt
	-Xlog:gc=debug::pid,time,uptime
	
	
	A Tool to Analyze GC Logs:		Universal GC Log Analyzer:		https://gceasy.io/
	
SEE ALSO:	
	https://www.baeldung.com/java-verbose-gc
	JEP 158: Unified JVM Logging:	https://openjdk.java.net/jeps/158
	
	
	
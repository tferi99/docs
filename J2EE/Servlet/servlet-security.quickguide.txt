============================
Servlet security quick guide
============================
1. Security terms
2. HTTP authentication 
2.1 Basic authentication
2.2 Digest authentication
3. Declarative security
3.1 Role-based security
4. Programmatic Security
5. Encryption
6. HTTPS
6.1 Specifying declarative HTTPS
6.2 Configuration HTTPS in Tomcat


1. Security terms
-----------------
principal	: A principal is one of the parties involved in a communication.
		  It could be a human user or a machine or maybe a piece of software.

	Principals often used in security literature:
		- Alice and Bob are the two principals trying to communicate
		- Eve is eavesdropper
		- Mallory is a malicious attacker trying to change data in communication
		- Trent is a trusted authority who credentials are sent to.
		
authentication	: Alice has to be able to prove that she is talking to Bob.

authorization	: to decide what action can be performed by an authenticated principal

credential	: To authenticate a principal, the principal has to provide a set of credentials. 
			  The credentials could be a user name/password pair, a fingerprint, a retinal scan,
			  a certificate, or anything that can uniquely identify the principal. 		
			  

			  
			  
2. HTTP authentication 
----------------------
HTTP defines a simple challenge/response authentication mechanism that supports two 
built-in authentication schemes, 
	- basic authentication 
	- and digest authentication
, each of which verifies that both parties in an exchange know a shared secret password. 


2.1 Basic authentication
-------------------------
Bob tries to get a resource from Alice:

Req1:
	GET /secureApp/secured/SecurityTest HTTP/1.1
	Host: localhost
Res1:
	HTTP/1.1 401 Unauthorized
	WWW-Authenticate: Basic realm="jspbook"
Req2:
	GET /secureApp/secured/SecurityTest HTTP/1.1
	Host: localhost
	Authorization: Basic ZnJlZDp0b21jYXQ=

HTTP authentication is based on challenge-response: Alice issues the challenge (Res1)
and Bob must respond with the appropriate credentials (Req2).

The "WWW-Authenticate" header (Res1 challange) contains the name of the authentication 
scheme ("Basic") and the security realm ("jspbook"). 
Bob's response (Req2) is to resubmit the request along with an additional HTTP 
"Authorization" header whose value contains the scheme ("Basic"), the realm ("jspbook"), 
and the credentials. The credentials are simply a user name and password that have been 
base-64 encoded.
	
If authentication fails, Alice sends back another "401 Unauthorized" response.
If authentication succeeds, then Alice will attempt an authorization check. This check 
determines whether the authenticated caller is allowed access to the resource. 
If authorization failsthat is, access is not allowed, then the server sends back 
a "403 Access denied" response.

Problems, limitations:
- The major problem with basic authentication is that the user name and password are 
  essentially SENT AS PLAIN TEXT. Base-64 encoding is not encryption and is completely 
  reversible by anyone. 
- Being stateless (HTTP) implies that authentication information must be included 
  with EVERY CLIENT REQUEST for a secured resource. 
  Once authenticated, Bob will typically cache the credentials.
  
 
2.2 Digest authentication
-------------------------
Req1:
	GET /secureApp/secured/SecurityTest HTTP/1.1
	Host: localhost
Res1:	
	HTTP/1.1 401 Unauthorized
	WWW-Authenticate: Digest realm="jspbook",
                         qop="auth",
                         nonce="5fef9f6239b0526151d6eebd12196cdc",
                         opaque="c8202b69f571bdf3ece44c4ce6ee2466"
Req2:
	GET /jspbook/secured/SecurityTest HTTP/1.1
	Host: localhost
	Authorization: Digest username="reader",
                      realm="jspbook",
                      qop="auth",
                      algorithm="MD5",
                      uri="/jspbook/secured/SecurityTest",
					  nonce="e60ede51960d0f15dd5b6a9bb715dbd3",
                      nc=00000001,
					  cnonce="d35d64e34652169436cef64df7327f41",
					  opaque="9da8ed8720b206d71ebce39cf0ca42bd",
					  response="49f194c2babc4cb28c4e7edc63655a64"

1. The "WWW-Authenticate" header contains the name of the authentication scheme 
   ("Digest") and the security realm ("jspbook") as before.
   
   The 'nonce' is a number UNIQUELY generated by the server, meaningful only to the server, 
   and valid only for the current authentication.
   
2. Once Bob receives the "401 Unauthorized" he resubmits the HTTP request with an 
   "Authorization" header whose "response" parameter is the CALCULATED DIGEST. Notice 
   that Bob NEVER SENDS THE PASSWORD ON THE WIRE, but only the digest is transmitted.
   Bob calculates a digest of the user name, password, realm, nonce, HTTP method, and 
   request URI using a secure digest algorithm. The default digest algorithm used is MD5.

3. When Alice receives this request, she also creates a message digest from the SAME DATA used 
   by the client. Alice then compares the value of the digest she has generated with the digest 
   sent by Bob.
   

2.3 Custom Form-Based Authentication
------------------------------------
You can build a custom form that will be presented to a user in a much more stylish fashion.

Configuration in web.xml:

	<web-app>
	  ...
	  <login-config>
	    <auth-method>FORM</auth-method>
	    <form-login-config>
	      <form-login-page>/login.jsp</form-login-page>
	      <form-error-page>/error.jsp</form-error-page>
	    </form-login-config>
	  </login-config>
	  ...
	</web-app>

login.jsp:

	<html>
	<body>
	  <form method="POST" action="j_security_check" >
	    User Name: <input type="text" name="j_username"><br/>
	    Password : <input type="password" name="j_password"><br/>
	    <input type="submit" value="Log on">
	  </form>
	</body>
	</html>

The only restriction is that the login page must direct the request to "j_security_check" 
and provide values for the "j_username" and "j_password" parameters.

When you try to get a secured page and you are not authenticated, it will you redirect to 
login page (302 Moved Temporarily).


3. Declarative security
-----------------------
The following security operations that all applications share:
	- Receives a request.
	- Authenticates the caller.
	- Checks the caller's authorization.
	- Allows or disallows access.

Because of the similarity in the security work different applications have to do, it is possible to 
abstract security away into a FRAMEWORK. In the case of J2EE, security frameworks are typically 
NOT PROGRAMMATIC but are DECLARATIVE.
It means that an application can specify via DEPLOYMENT settings (i.e., web.xml) the level of 
security that a given resource needs, AND THAT SECURITY IS PROVIDED BY THE WEB APPLICATION CONTAINER.


3.1 Role-based security
-----------------------
The first type of declarative security we will discuss is ROLE-BASED security. 
In the Servlet world security is based on two things: resources and roles.

- Resources are the things that need protecting.
- Roles are the users authorized to access those resources.


3.2 Declarative security example
--------------------------------
web.xml:
--------
...
<web-app>
...
    <security-constraint>
        <web-resource-collection>
            <web-resource-name>SecuredBookSite</web-resource-name>
            <url-pattern>/secured/*</url-pattern>
            <http-method>GET</http-method>
            <http-method>POST</http-method>
        </web-resource-collection>
        <auth-constraint>
            <role-name>admin</role-name>
        </auth-constraint>
    </security-constraint>
    <login-config>
      <auth-method>BASIC</auth-method>
      <realm-name>Book Site</realm-name>
    </login-config>
...

This example enable accessing resources under 'secured' directory only for admins.
Authentication method is BASIC.
Tags:

web-resource-name	: It does not matter what you choose as a name.
login-config		: authentication login settings
role-name			: access enabled for this role
realm-name			: display info for login dialog



3.3. Declarative security in Tomcat
------------------------------------
Tomcat user definitions are stored as "realms", and Tomcat comes with three realm 
implementations: 
 - a memory realm (the tomcat-users.xml file you have just seen)
 - a JDBC realm
 - and a JNDI realm
 
Realms are configured as part of Tomcat's server.xml file. 


4. Programmatic Security
------------------------
To refine declarative security Servlet API provides the following methods:

- String getAuthType()
	The getAuthType() method returns a String object that represents the name of 
	the authentication scheme used to protect the Servlet. While not usually helpful, 
	this can be used to determine how form information was submitted.

- boolean isUserInRole(java.lang.String role)
	The isUserInRole() method returns a boolean value: true if the user is in the 
	given role or false if they are not.

- String getProtocol()
	The getProtocol() method returns a String object representing the protocol that 
	was used to send the request. This value can be checked to determine if a secure 
	protocol was used.

- boolean isSecure()
	The isSecure() method returns a boolean value representing if the request was 
	made using HTTPS. A value of true means it was and the connection is secure. 
	A value of false means the request was not.

- Principle getUserPrinciple()
	The getUserPrinciple() method returns a java.security.Principle object that contains
	the name of the current authenticated user.


Example:

void doPost(HttpServletRequest req,HttpServletResponse res)
{
	if (req.isUserInRole("ManagersRole")) {
		// Do some Manager stuff
	} else if (req.isUserInRole("ReaderRole")) {
		// Do some Sales stuff
	} else {
		throw Exception("User does not have access!");
	}
}

Role names are NOT hard coded. 'security-role-ref' element may be used to reference to 
a role.

web.xml:

	...
	<servlet>
	    <servlet-name>FooServlet</servlet-name>
	    <servlet-class>com.jspbook.FooServlet</servlet-class>
	    <security-role-ref>
	        <!-- role-name is used in the application-->
	        <role-name>ReaderRole</role-name>
	        <role-link>Reader</role-link>
	    </security-role-ref>
	</servlet>

	<security-role>
	    <role-name>Reader</role-name>
	</security-role>
	...

You can specify role references in servlet tag.

5. Encryption
-------------
symmetric key 	: represents a shared secret, and the same key is used to both encrypt and decrypt the data. 
				  The problem with symmetric key encryption is "key exchange". 

asymmetric key	: a key that is split into two parts: the private key and the public key. 
				  Either can decrypt data encrypted by the otherthat is, data encrypted by the public key 
				  only can be decrypted by the private and vice versa.
				  

				  
Encrypting data with the public key 
	is useful, as that data can only be decrypted with the private key. 
	That means that NO ONE CAN READ THAT DATA EXCEPT THE PRIVATE KEY OWNER. That is, if Bob encrypts data 
	using Alice's public key, only Alice can decrypt that data.

What about encrypting data using a private key? 
	If Alice encrypts data using her private key, anybody can decrypt it with Alice's public key 
	(the key is public and so is available to anybody). This is also extremely useful as it can 
	be used TO PROVE IDENTITY.

	Alice sends a plain text to Bob, and also sends the same text encrypted by private key.
	
5.1 SSL Handshake
-----------------

Client                                                Server
------                                                ------

     Client Hello : random# + cipher list             
1 ------------------------------------------------------>	

     Server Hello : random#2 + cipher + server cert
2 <------------------------------------------------------

     Client Finish : client cert + MAC (message authentication code) + ...
3 ------------------------------------------------------->

     Server Finish : ...
4 <-------------------------------------------------------


6. HTTPS
--------
6.1 Specifying declarative HTTPS
--------------------------------
The <user-data-constraint> element in <security-constraint> element can be used to 
specify the level of security.
The child element transport-guarantee can be used to set a value of either NONE, INTEGRAL,
or CONFIDENTIAL. 

- The NONE value is the default and requires no level of security be enforced. 

- The INTEGRAL value specifies that a container must ensure the integrity of informationthat 
  is, it has not changed during transit but it might have been read by others. 
  
- The CONFIDENTIAL value requires that information sent in a request and response is both 
  private and unchangedfor example, SSL.


	<security-constraint>
	   <web-resource-collection>
	     <web-resource-name>SecuredBookSite</web-resource-name>
	     <url-pattern>/tlssecured/*</url-pattern>
	     <http-method>GET</http-method>
	     <http-method>POST</http-method>

	   </web-resource-collection>
	   <user-data-constraint>
	     <transport-guarantee>CONFIDENTIAL</transport-guarantee>
	   </user-data-constraint>
	 </security-constraint>

	 
6.2 Configuration HTTPS in Tomcat
---------------------------------
1. Download and installing JSSE

	NOTE: JSSE integrated into the Java 2 SDK, Standard Edition, v 1.4

2. Create a certificate keystore by executing the following command:

	$JAVA_HOME/bin/keytool -genkey -alias tomcat -keyalg RSA

	Password must be: changeit
	It will create ---> $HOME/.keystore

3. Uncomment the "SSL HTTP/1.1 Connector" entry in $CATALINA_HOME/conf/server.xml
   and tweak as necessary.	

  
  